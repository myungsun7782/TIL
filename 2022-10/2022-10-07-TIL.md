# 2022년 10월 7일(금)

---

### Today I Learned

- [iOS-Swift] 클래스와 상속(3)

---

## 생성자

**1) 지정 생성자(Designated) - init(파라미터)**

- **init( …. ) 형태를 가지는 생성자**

- 지정 생성자는 모든 저장 속성을 초기화해야 함

  - 저장 속성의 선언과 동시에 값을 저장하거나, 저장 속성을 옵셔널 타입으로 선언하는 것도 가능

- 오버로딩이 가능하므로, 다양한 파라미터 조합으로 지정 생성자 구현 가능

- (따로 지정하지 않아도) 모든 저장 속성이 초기화 되는 경우, 기본 생성자 자동 제공 —> **init()**

- **생성자를 1개 이상 구현하면 기본 생성자를 제공하지 않음**

- 코드 예시

  - 구조체 지정 생성자 코드 예시

  ```swift
  // 값 타입(구조체)의 경우 자체 지정 생성자 작성할 때 
  // 생성자 내에서 self.init( ... )를 사용하여 다른 이니셜라이저를 호출하도록 할 수 있음 
  struct Color {
  		let red, green, blue: Double
  		
  		init() { // 구조체는 다른 생성자를 호출하는 방식도 가능 ⭐️
  		    self.init(red: 0.0, green: 0.0, blue 0.0)
  		}
  
  		init(white: Double) { // 구조체는 다른 생성자를 호출하는 방식도 가능 ⭐️
  				self.init(red: white, green: white, blue: white)
  		}
  
  		init(red: Double, green, Double, blue: Double) {
  				self.red = red 
  				self.green = green 
  				self.blue = blue 
  		}
  }
  ```

  - 클래스 지정 생성자 코드 예시

  ```swift
  // 다른 생성자(지정 생성자)를 호출하는 생성자를 '편의 생성자'라고 한다.
  class Color {
  		let red, green, blue: Double 
  		
  		convenience init() {
  				self.init(red: 0.0, green: 0.0, blue: 0.0)
  		}
  
  		convenience init(white: Double) {
  				self.init(red: white, green: white, blue: white)
  		}
  
  		init(red: Double, green: Double, blue: Double) {
  				self.red = red 
  				self.green = green 
  				self.blue = blue 
  		} 
  }
  /**========================================================================
   - 일단 편의 생성자는 편리하게 생성하기 위한 서브(Sub)생성자라고 보면됨(메인이 아닌)
   - ===> (메인) 지정 생성자에 의존하는 방식 (지정 생성자 호출)
  
   - 지정 생성자는 모든 속성을 초기화 해야함
   - 편의 생성자는 모든 속성을 초기화 할 필요가 없음(편의적 성격)
  
    ⭐️
   - 클래스는 상속을 지원하므로, 변수가 여러 개 이고,
   - 여러 지정 생성자를 지원했을때 상속 관계에서 개발자가 실수할 수 있는 여러가지 가능성이 있음.
   - 따라서, 초기화 과정을 조금 간편하게 만들고,
   - 상속관계에서 개발자가 실수 할 수 있는 여러가능성을 배제하기 위한 생성자임
  
   - 반대로 말하자면 모든 속성을 초기화하지 않는다면 ===> 편의생성자로 만드는 것이 복잡도나 실수를 줄일 수 있음
   - 결국, 생성자의 가능한 중복을 없애고 다른 지정 생성자를 호출하는 패턴으로 구현해야 함
   ==========================================================================**/
  ```

  - 클래스의 상속과 지정 / 편의 생성자 사용 코드 예시

  ```swift
  class Aclass {
  		var x: Int
  		var y: Int
  
  		init(x: Int, y: Int) {
  			self.x = x 
  			self.y = y
  		}
  		
  		convenience init() {
  				self.init(x: 0, y: 0)
  		}
  }
  
  // 상속이 일어나는 경우 ⭐️
  class Bclass: Aclass {
  		var z: Int 
  		
  		init(x: Int, y: Int, z: Int) { // 실제 메모리에 초기화 되는 시점 
  				self.z = z // ⭐️ (필수)
  				// self. y = y // 불가 (메모리 셋팅 전)
  				super.init(x: x, y: y) // ⭐️ (필수) 상위의 지정 생성자 호출 
  				// self.z = 10
  				// self.x = 20
  				// self.y = 30 
  		}
  
  		convenience init(z: Int) {
  				// self.z = 7 // ---> self에 접근 불가 --> 지정 생성자 호출 전이므로 저장 속성 z가 메모리에 생성되지 않았기 때문에 접근할 수가 없다.
  				self.init(x: 0, y: 0, z: z)
  				// self.z = 10 
  		} 
  		
  		convenience init() {
  				self.init(z: 0) 
  		}
  
  		func doSomething() {
  				print("Do Something Method Called")
  		}
  }
  
  let a = Aclass(x: 1, y: 1)
  let a1 = Aclass()
  
  let b = Bclass(x: 1, y: 1, z: 1)
  let b1 = Bclass(z: 10) // 편의 생성자 호출
  let b2 = Bclass() // 편의 생성자 호출 
  
  b1.x // 0
  ```

**2) 편의 생성자(Convenience) - 상속과 관련 - convenience init(파라미터)**

- 지정 생성자보다 적은 갯수의 파라미터로 보다 편리하게 생성하기 위한 **서브(Sub) 개념의 생성자**
- 편의 생성자(convenience)는 지정 생성자(designated)에 의존 및 호출(지정 생성자가 저장 속성 초기화)
- **초기화 과정을 간편하게 제공하기 위함**
- 실질적으로 가능한 지정 생성자의 갯수를 줄이고, 편의 생성자에서 지정 생성자 호출하도록 하는 것이 바람직
- 상속했을 때, 편의 생성자의 경우 **서브 클래스에서 재정의를 못함**(하위에서 호출불가가 원칙)
- 편의 생성자는 다른 편의 생성자를 호출하거나, 지정 생성자를 호출해야함(궁극적으로는 지정 생성자를 호출)

**상속관계에서 생성자 위임 규칙**

(1) 델리게이트 업 (Delegate up)

- 서브 클래스의 지정 생성자는 슈퍼 클래스의 지정 생성자를 반드시 호출해야 함
- (하위 클래스의 저장 속성을 초기화하고 상위 클래스의 저장 속성을 초기화하는 과정)

(2) 델리게이트 어크로스 (Delegate across)

- 편의 생성자는 동일한 클래스에서 다른 편의 생성자 또는 지정 생성자를 호출해야 하고, 궁극적으로는 지정생성자를 호출해야 함
- (궁극적으로 지정생성자만이 해당 단계의 모든 저장값을 초기화 함)

**지정 생성자 / 편의 생성자 상속과 재정의 규칙 ⭐️**

- 생성자
  - 생성자는 기본적으로 **상속되지 않고 재정의 원칙**(생성자는 모든 저장 속성을 초기화하는 도구이기 때문에, 서브 클래스에 최적화 안 되어 있음)
  - 원칙: **1) 상위 지정 생성자**와 **2) 현재 단계의 저장 속성**을 고려해서 구현 ⭐️
  - 1단계
    - (상위)지정 생성자: 재정의 필수 고려(1. 지정, 2. 편의, 3. 안할 지) / 예외적 자동 상속
    - (상위)편의 생성자: 재정의 불가(호출불가) / 예외적 자동 상속 (슈퍼 클래스와 동일한 모든 지정 생성자가 존재할 때)
  - 2단계
    - **(현재 단계의) 모든 저장 속성 초기화 및 상위의 지정 생성자 호출**
    - **(편의 생성자 구현시) 지정 생성자를 호출**
- 코드 예시

```swift
// 기본(Base) 클래스 
class Aclass {
		var x = 0
		
		// init() {} // 기본 생성자가 자동으로 제공됨 --> 저장 속성 x에 기본 값이 설정되어 있기 때문에
}

let a = Aclass()
print("a 출력해보기 a.x: \\(a.x)")

// 상위의 지정 생성자 ⭐️
// init() 
class Bclass: Aclass {
		var y: Int 
		
		// [1단계] 상위의 지정 생성자 고려
		// 상위에 동일한 이름이 있으므로 재정의 해야함 (이 형태는 안됨)
		// init() { }

		// 선택 1) 지정 생정자로 재정의 
		override init() { // 상위 클래스와 "이름이 동일한 생성자" 구현은 재정의만 가능함(올바른 재정의) (지정생성자로 구현)
				self.y = 0 // 자기 단계의 저장 속성을 먼저 초기화 
				super.init() // 상위 클래스의 저장 속성을 초기화하기 위해 상위 클래스에 위임을 해서 초기화를 시킨다. 
		} 
		
		// 선택 2) 서브 클래스에서 편의 생성자로 구현해보기 
		// 상위 클래스와 "이름이 동일한 생성자" 구현은 재정의만 가능함(올바른 재정의) (지정생성자 필요) 
		// override convenience init() { 
				// self.init(y: 0)
		// }

		// 선택 3) 재정의 하지 않을 수도 있음 (상속 안함) 
		
		// [2단계] (현재 단계의) 생성자 구현 
		init(y: Int) {
				self.y = y 
				super.init() 
		}
}

let b = Bclass()
print("b 출력해보기 b.x: \\(b.x), b.y: \\(b.y)")  // b 출력해보기 b.x: 0 , b.y: 0 

// 상위의 지정 생성자 ⭐️
// init()
// init(y: Int) 
class Cclass: Bclass {
		var z: Int 

		override init() { // 상위 클래스와 "이름이 동일한 생성자" 구현 (올바른 재정의)
				self.z = 0 // 자기 단계의 저장 속성을 먼저 초기화 
				super.init() // 2단계 값설정(커스텀)없고, 상위 구현에 기본 init()만 있는 경우 생략 가능(암시적 요청) 
		}

		init(z: Int) {
				self.z = z // 자기 단계의 저장 속성을 먼저 초기화 
				super.init() // 2단계 값설정(커스텀)없고, 상위 구현에 기본 init()만 있는 경우 생략 가능(암시적 요청) 
}
let c = Cclass()
print("c 출력해보기 c.x: \\(c.x), c.y: \\(c.y), c.z: \\(c.z)") // c 출력해보기 c.x: 0, c.y: 0, c.z: 0 

let d = Cclass(z: 1)
print("d 출력해보기 d.x: \\(d.x), d.y: \\(d.y), d.z: \\(d.z)") // d 출력해보기 d.x: 0, d.y: 0, d.z: 1
```

- 애플 공식문서 코드 예시

```swift
class Vehicle {
		var numberOfWheels = 0 
		var description: String {
			return "\\(numberOfWheels) wheel(s)"
		}
		// init() { } 
}
// numberOfWheels의 저장 속성에 기본 값을 제공, 생성자 구현하지 않았으므로
// ---> 기본 생성자 init() 자동 제공 

let vehicle = Vehicle()
print("Vehicle: \\(vehicle.description)") // Vehicle: 0 wheel(s)

// 상위의 지정 생성자 ⭐️
// init() 

// 서브 클래스 정의
class Bicycle: Vehicle {
		// 커스텀 init() 정의 ---> 생성자가 상위 클래스의 이름과 동일 하므로 재정의 키워드 필요 
		// 상위 지정 생성자 호출하여 메모리 초기화 후, 상위에서 구현한 속성에 접근하여 2로 셋팅(2단계 값 설정)
		override init() {
				super.init() // 슈퍼 클래스 호출 반드시 필요 
				numberOfWheels = 2  // 초기화의 2단계 값 설정 
		}
}
let bicycle = Bicycle() 
print("Bicycle: \\(bicycle.description)") // Bicycle: 2 wheel(s)

// 상위의 지정 생성자 ⭐️
// init() 

// 서브 클래스 정의 
class Hoverboard: Vehicle {
		var color: String 

		// (읽기) 계산 속성 재정의 
		override var description: String {
				return "\\(super.description) in a beautiful \\(color)")
		}

//  override convenience init() { 
//      self.init(color: "Red")
//	}

		init(color: String) {
				self.color = color // (현재 클래스) 저장 속성 초기화 
				super.init() // ---> 여기서 암시적으로 호출 됨(이 경우 생략 가능)
		}
}

// 생성자에서 Hoverboard 클래스는 색상 속성만 설정 
// 2단계 값설정(커스텀)없고, 상위 구현에 기본 init()만 있는 경우 생략 가능(암시적 요청)⭐️
let hoverboard = Hoverboard(color: "Silver")
print("Hoverboard: \\(hoverboard.description)") // Hoverboard: 0 wheel(s) in a beautiful silver 
```

**클래스의 지정, 편의 생성자 상속의 예외사항**

- 지정 생성자 자동 상속

  - 저장 속성 기본 값 설정 및 어떤 재정의도 안했을때

    - 새 저장 속성이 아예 없거나, 기본 값이 설정되어 있다면 (실패 가능성 배제)

      —> 슈퍼 클래스의 지정 생성자 모두 자동 상속(하위에서 어떤 재정의도 하지 않으면)

- 편의 생성자 자동 상속

  - 상위 지정 생성자를 모두 상속하는 경우
    1. (위의) **지정 생성자 모두 자동 상속**의 경우
    2. 상위의 **지정 생성자 모두 재정의**하는 경우 (실패 가능성 배제)
  - 결국, 모든 지정생성자를 상속하는 상황이 되면 편의 생성자는 자동으로 상속됨

- 코드 예시(애플 공식 문서 예제)

```swift
// 음식
class Food {
		var name: String 
		
		init(name: String) { // 지정 생성자 
				self.name = name 
		}
		
		convenience init() { // 편의 생성자 ---> 지정 생성자 호출 
				self.init(name: "[Unnamed]")
		} 
}
let namedMeat = Food(name: "Bacon") 
namedMeat.name // Bacon

let mysteryMeat = Food() 
mysteryMeat.name // [Unnamed]

// 상위의 지정 생성자 ⭐️
// init(name: String) --> 지정 생성자
// convenience init() --> 편의 생성자 

// 레시피 재료 
class RecipeIngredient: Food {
		var quantity: Int 

		init(name: String, quantity: Int) { // 모든 속성 초기화 
				self.quantity = quantity 
				super.init(name: name) 
		}

		override convenience init(name: String) { // 상위 지정 생성자를 편의 생성자로 재정의 --> 지정 생성자 호출 
				self.init(name: name, quantity: 1)
		}
		
		// convenience init() { }  // 자동 상속 (예외 규칙)
}

let oneMysteryItem = RecipeIngredient()
oneMysteryItem.name // [Unnamed]
oneMysteryItem.quantity // 1

let oneBacon = RecipeIngredient(name: "Bacon")
oneBacon.name // Bacon 
oneBacon.quantity // 1 

let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6) 
sixEggs.name // Eggs 
sixEggs.quantity // 6 

// 상위의 지정생성자 ⭐️
// init(name: String, quantity: Int)          지정생성자
// override convenience init(name: String)    편의생성자
// convenience init()                         편의생성자

// 쇼핑 아이템 리스트 
class ShoppingListItem: RecipeIngredient {
		var purchased = false // 모든 저장 속성에 기본 값 설정 
		var description: String {
				var output = "\\(quantity) x \\(name)"
				output += purchased ? " ✔" : " ✘"
				return output 
		}

		// init(name: String, quantity: Int) {} // 지정 생성자 모두 자동 상속 
		// convenience init(name: String) {} // 따라서 ---> 편의 생성자 모두 자동 상속 됨 
		// convenience init() {} // 따라서 ---> 편의 생성자도 모두 자동 상속 됨 
}

var breakfastList = [ 
		shoppingListItem(),
		shoppingListItem(name: "Bacon"),
		shoppingListItem(name: "Eggs", quantity: 6)
]

breakfastList[0].name // [Unnamed]
breakfastList[0].name = "Orange Juice"
breakfastList[0].purchased = true 

for item in breakfastList {
		print(item.description)
}

// 출력결과 ============================
// 1 x Orange juice ✔
// 1 x Bacon ✘
// 6 x Eggs ✘
```

**3) 필수 생성자(Required) - 상속과 관련 - Required init(파라미터)**

- 클래스의 생성자 앞에 required(필수의) 키워드를 붙이면 하위 클래스에서 반드시 해당 생성자를 구현해야 함
  - 해당 생성자의 의미 —> 파라미터 이름 및 타입이 동일한
- 하위 클래스에서 필수 생성자 구현시, override(재정의) 키워드 없이 required(필수의) 키워드만 붙이면 됨
- 필수 생성자 자동 상속 조건
  - 다른 지정 생성자를 구현 안하면, 자동으로 필수 생성자 상속 됨⭐️
  - 다른 지정 생성자를 구현하면, 필수 생성자를 다시 구현해야 함
- 코드 예시

```swift
class Aclass {
		var x: Int 
		required init(x: Int) {
				self.x = x
    }
}

// 클래스 생성자 앞에 required(요구된/필수의) 키워드 사용시
// 하위 생성자는 반드시 해당 필수 생성자를 구현 해야 함 

class Bclass: Aclass {
//    다른 지정 생성자를 구현 하지 않았기 때문에, 필수 생성자 자동으로 상속 됨
//		required init(x: Int) {
//				super.init(x: x)
//		}
}

// 하위 클래스에서 필수 생성자를 구현할 때는, 상위 필수 생성자를 구현하더라도 
// override(재정의) 키워드가 필요 없고, required 키워드만 붙이면 됨 

class Cclass: Aclass {
		init() {
				super.init(x: 0)
				print("init() called")
		}
		// 지정 생성자 init()을 구현 했기 때문에 
		// required init(x: Int) 필수 생성자 구현해야 함 
		required init(x: Int) {
				super.init(x: x)
				print("required init() called")
		}
}

// 필수 생성자 사용 예시(UIView)
class AView: UIView {
//		required init?(coder: NSCoder) { // 구현을 안해도 자동상속 --> 따로 지정생성자를 구현하지 않았기 때문에
//				fatalError("init(coder:) has not been implemented")
//		}
}

class BView: UIView {
		override init(frame: CGRect) {
				super.init(frame: frame)
		}
		
		// 위에 지정 생성자를 구현했기 때문에 required init?(coder: NSCoder) 필수 생성자 구현해야 함
		required init?(coder: NSCoder) {
				fatalError("init(coder:) has not been implemented")
		}
}
```

**4) 실패가능 생성자(Failable) - init?(파라미터)**

- 인스턴스 생성시, 

  실패 가능성을 가진 생성자(클래스, 구조체, 열거형 가능)

  - 실패가 불가능하게 만들어서, 아예 에러가 나고 앱이 완전히 꺼지는 가능성보다는 실패 가능성 생성자를 정의하고 그에 맞는 예외 처리를 하는 것이 더 올바른 방법임

- 인스턴스 생성 실패시 **nil을 리턴**

- 생성자에 ?을 붙여서, init?(…)으로 정의(다만, 오버로딩으로 인한 구분이 안되므로, 해당 이름을 가진 생성자는 유일한 생성자여야 함)

- **init?(실패 가능 생성자)은 init(실패 불가능 생성자)보다 더 넓은 개념**

1. 동일 단계 / 상속 관계에서의 

   호출

   - **실패 불가능 생성자**는 다른 **실패가능 생성자**를 호출 불가능

2. 상속 관계에서의 

   재정의

   - (상위) **init?** —> (하위) **init** (O) (강제 언래핑 활용 가능)
   - (상위) **init** —> (하위) **init?** (X)

- **init! 생성자**는 init?과 유사하게 취급하면 됨
- 코드 예시

```swift
struct Animal {
		let species: String

		// 실패 가능 생성자
		init?(species: String) {
				if species.isEmpty {
					return nil 
				}
				self.species = species 
		}
}

let a = Animal(species: "Giraffe") // 인스턴스 생성 
let b = Animal(species: "") // 문자열이기에 유효한 타입이지만 ---> nil 

// 엄밀히 말하면 생성자는 값을 반환하지 않고, 초기화가 끝날 때 까지 모든 저장 속성이 값을 가져 올바르게 초기화되도록 하는 것임 
// 초기화 성공을 나타내기 위해 return 키워드를 사용하지 않음(문법적 약속) 

// 열거형의 실패가능 생성자 활용 
enum TemperatureUnit {
		case kelvin
		case celsius
		case fahrenheit

		init?(symbol: Character) {
				switch symbol {
				case "K":
						self = TemperatureUnit.kelvin
				case "C": 
						self = TemperatureUnit.celsius
				case "F": 
						self = TemperatureUnit.fahrenheit
				default: 
						return nil 
				}
		}
}

let c: TemperatureUnit = TemperatureUnit.celsius // TemperatureUnit()
let f: Temperatureunit? = TemperatureUnit(symbol: "F") // 실패 가능성 있음 --> symbol에 올바르지 않은 값이 들어갈 수도 있기 때문 

// 열거형의 원시값 설정(실패가능 생성자의 구현과 유사)
enum TemperatureUnit1: Character {
		case kelvin = "K"
		case celsius = "C"
		case fahrenheit = "F"
}

// 원시 값이 있는 열거형은 자동으로 실패가능 생성자 init?(rawValue: )를 구현함 --> 일치하면 인스턴스 생성, 아니면 nil 리턴
let f1: TemperatureUnit1? = TemperatureUnit1(rawValue: "F") // .fahrenheit
let x: TemperatureUnit1? = TemperatureUnit1(rawValue: "X") // nil

// 상속 관계에서의 호출 예제 
// 상품 
class Product {
		let name: String

		// 실패 가능 생성자
		init?(name: String) {
				if name.isEmpty { return nil }
				self.name = name 
		}
}

// 온라인 쇼핑 카트의 항목을 모델링
class CartItem: Product {
		let quantity: Int

		// 실패 가능 생성자 
		init?(name: String, quantity: Int) { 
				if quantity < 1 { return nil } // 상품의 갯수가 1보다 작으면 --> 카트 항목 생성 실패 
				self.quantity = quantity // 수량이 한 개 이상이면 --> 초기화 성공 
				super.init(name: name)  // "" (빈문자열이면) --> 실패 가능 위임 OK
		}
}

if let twoSocks = CartItem(name: "sock", quantity: 2) {
		print("아이템: \\(twoSocks.name), 수량: \\(twoSocks.quantity)")
}

if let zeroShirts = CartItem(name: "shirt", quantity: 0) {
		print("아이템: \\(zeroShirts.name), 수량: \\(zeroShirts.quantity)")
} else {
		print("zero shirts를 초기화 불가(갯수가 없음)")
}

if let oneUnnamed = CartItem(name: "", quantity: 1) {
		print("아이템: \\(oneUnnamed.name), 수량: \\(oneUnnamed.quantity)")
} else {
		print("이름 없는 상품 초기화 불가")
}

// 상속관계에서 재정의 예제 
// 서류라는 클래스 정의
class Document {
		var name: String?

		init() {} // 서류 생성 (실패 불가능 생성자) (이름은 nil로 초기화)

		init?(name: String) { // 실패가능 생성자 --> 이름이 "" 빈문자열일 때, 초기화 실패(nil)
		    if name.isEmpty { return nil }
				self.name = name 
		}
}

// 자동으로 이름 지어지는 서류
class AutomaticallyNamedDocument: Document {
		override init() { // 재정의 (상위) 실패불가능 ---> (하위) 실패불가능 
				super.init()
				self.name = "[Untitled]"
		}

		override init(name: String) { // 재정의 (상위) 실패가능 ---> (하위) 실패 불가능 
				super.init()
				if name.isEmpty {
						self.name = "[Untitled]"
				} else {
						self.name = name 
				}
		}
}

let autoDoc = AutomaticallyNamedDocument(name: "")
autoDoc.name // [Untitled]

// 이름없는(Untitled) 서류 
class UntitledDocument: Document {
		override init() { // 재정의 (상위) 실패가능 ---> (하위) 실패불가능 
				// super.init() 
				super.init(name: "[Untitled]")! // 강제 언래핑(!)으로 구현 ⭐️
		}
}
```

**5) 소멸자(Deinitializer)**

- 인스턴스 해제시, 정리가 필요한 내용을 정의
- 클래스에는 최대 1개의 소멸자(Deinitializer)가 존재
- 인스턴스가 메모리에서 제거되기 직전에 자동으로 호출되는 메서드 부분
- 코드 예시

```swift
/**==================================================================
 - 소멸자
 - 인스턴스가 메모리에서 해제되기 직전 정리가 필요한 내용을 구현하는 메서드
 - 클래스 정의시 클래스에는 최대 1개의 소멸자(deinitializer)를 정의 가능
 - 소멸자는 파라미터(매개 변수)를 사용하지 않음
 
 - 소멸자(초기화 해제) 작동 방식
 - Swift는 클래스의 인스턴스(객체)를 자동 참조 계산(ARC) 방식을 통해 메모리 관리
 - 일반적인 경우(강한 순환 참조를 제외한)에는 메모리에서 해제될때
 - 수동으로 관리를 수행할 필요가 없음
 
 
 - 그러나 특별한 작업을 수행중인 경우, 몇가지 추가 정리를 직접 수행해야 할 수 있음
 - 예) 인스턴스에서 파일을 열고 일부 데이터를 쓰는 경우,
      클래스 인스턴스가 할당 해제되기 전에 파일을 닫아야 파일에 손상이 안 갈 수 있음
 - 소멸자에서는 인스턴스의 모든 속성에 액세스 할 수 있으며
   해당 속성을 기반으로 동작을 수정할 수 있음 (예 : 닫아야하는 파일의 이름 조회)
 
 
 [상속이 있는 경우]
 - 상위클래스 소멸자는 해당 하위클래스에 의해 상속됨
 - 상위클래스 소멸자는 하위클래스 소멸자의 실행이 끝날 때 자동으로 호출됨
 - 상위클래스 소멸자는 하위클래스가 자체적인 소멸자를 제공하지 않더라도 항상 호출됨
====================================================================**/
class Aclass {
    var x = 0
    var y = 0
    
    deinit {
        print("인스턴스의 소멸 시점")
    }
}

var a: Aclass? = Aclass()
a = nil   // 메모리에 있던 a인스턴스가 제거됨

class Bclass: Aclass {
    var a = 0
}

var b: Bclass? = Bclass()
b = nil

// 생성자는 필요한 만큼 구현할 수 있지만, 소멸자는 하나만 구현 가능 함
// 소멸자는 직접 호출할 수 없고(직접 호출하는 문법이 없고), 
// 인스턴스(객체)가 메모리에서 제거되기 직전에 자동으로 호출됨⭐️
```