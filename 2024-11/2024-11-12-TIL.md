# 2024-11-12-TIL

안녕하세요.

오늘은 컴퓨터 구조에서 보조장치를 포함해 다양한 입출력 장치들이 컴퓨터 내부와 정보를 주고받는 방식인 입출력 기법에 대해 알아보겠습니다.

# 입출력 기법

## 장치 컨트롤러와 장치 드라이버

- 다양한 외부 장치가 컴퓨터 내부와 어떻게 연결되고 소통되는지를 알기 위해서는 우선 **장치 컨트롤러(device controller)**와 **장치 드라이버(device driver)**라는 개념을 알아야 함.
- 같은 입출력장치라 하더라도 제조사마다 규격과 작동 방식이 상이할 수 있어, CPU 입장에서 모든 입출력장치의 작동 방식을 아는 것은 어려운 일입니다. 따라서, 입출력장치는 CPU와 직접 연결되어 정보를 주고받지 않고, 장치 컨트롤러라는 하드웨어를 통해 연결됨. 모든 입출력장치는 각자의 장치 컨트롤러를 통해 컴퓨터 내부와 연결되어 정보를 주고받음
- 즉, 장치 컨트롤러는 CPU와 입출력장치 사이의 통신을 중개하는 중개자 역할의 하드웨어인 셈. CPU가 직접 하드 디스크를 회전시키거나 마이크의 입력 값을 해석하고, 프린트를 작동시키는 것이 아니라, 장치 컨트롤러의 중개를 통해 입출력장치가 작동하는 것임.
  - 참고로, 장치 컨트롤러에는 RAM과 같은 저장장치가 있는 경우가 많음. CPU와 정보를 주고받는 과정에서 기억해야 하는 많은 중간 값들이 장치 컨트롤러의 저장장치에 저장됨. 이 저장장치 역시 휘발성인 경우가 많아, 입출력 작업 도중에 연결을 해제하거나 연결된 장치를 안전 제거하지 않으면 입출력 데이터에 문제가 발생할 수 있음
- CPU가 실행하는 것은 결국 프로그램. 그리고 CPU는 장치 컨트롤러와 상호작용하며 입출력장치를 작동시킴. 이는 CPU가 장치 컨트롤러와 상호작용함으로써 입출력장치를 작동시키는 것 또한 CPU가 실행하는 프로그램을 통해 이루어진다는 말과 같음.
- 바로 이 프로그램이 **장치 드라이버**임. 일반적으로 장치 컨트롤러마다 이를 작동시키는 장치 드라이버라는 프로그램이 있음. 장치 드라이버란 **장치 컨트롤러의 동작을 알고, 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있도록 하는 프로그램**임.
- 컴퓨터가 장치 드라이버를 인식하지 못한다면 장치 컨트롤러와 정보를 주고받는 방법을 알 수 없으므로 입출력장치를 실행하지 못할 것임.



## 프로그램 입출력(Programmed I/O)

- **프로그램 속 명령어로 입출력 작업을 수행하는 방법**
- CPU는 "프린터 컨트롤러의 상태를 확인하라", "하드 디스크 컨트롤러에 10을 써라"와 같은 입출력 명령어를 실행함으로써 장치 컨트롤러와 상호작용할 수 있고, 이를 통해 입출력 작업을 수행함.

## 인터럽트 기반 입출력: 다중 인터럽트

- 키보드, 마우스 모니터, 스피커 등의 입출력장치를 동시에 사용하는 상황을 생각해보자. 이 경우에 CPU는 동시 다발적으로 발생하는 키보드, 마우스, 모니터, 스피커 인터럽트를 모두 처리해야 함.

- 이렇게 인터럽트가 여러 입출력장치로부터 동시다발적으로 발생하는 경우에는 어떻게 인터럽트를 처리해야 할까?

  - CPU가 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리할 경우, 다른 하드웨어 인터럽트를 받아들이지 않기 때문에 CPU는 기본적으로 다음과 같이 인터럽트가 발생한 1~8의 순서대로 인터럽트 서비스 루틴을 순차적으로 실행하게 됨.
  - 하지만, 모든 인터럽트가 아래 그림과 같이 처리되지는 않음. 인터럽트 중에서도 우선순위가 더 높은 인터럽트가 우선적으로 처리되는 경우가 일반적임. 예를 들어, 현재 CPU가 인터럽트 A를 처리하는 도중에 또 다른 인터럽트 B가 들어왔다고 가정해보자.

  <img width="428" alt="image" src="https://github.com/user-attachments/assets/ae00f102-f536-465a-8c5e-cb887f884474">

  (그림 출처: 이것이 취업을 위한 컴퓨터 과학이다)

  - 만약, 지금 처리중인 인터럽트 A보다 B의 우선순위가 높다면, CPU는 인터럽트 A의 실행을 잠시 멈추고 B를 처리한 뒤에 다시 A를 처리함. 반대로 인터럽트 A보다 B의 우선순위가 낮다면, CPU는 인터럽트 A를 모두 처리한 뒤에 B를 처리함.

- CPU는 플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우, 혹은 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트인 NMI(Non-Maskable Interrupt)가 발생한 경우, 이렇게 우선순위가 높은 인털버트부터 먼처 처리하게 됨

- 흔히 다중 인터럽트를 처리하기 위해서는 **프로그래머블 인터럽트 컨트롤러(이하 PIC)(Programmable Interrupt Controller)**라는 하드웨어가 사용됨.

- PIC는 여러 장치 컨트롤러에 연결되어 있어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤, CPU에게 지금 처리해야 할 하드웨어 인터럽트가 무엇인지를 알려주는 장치임.

<img width="839" alt="image" src="https://github.com/user-attachments/assets/cb4bddf9-5975-4b34-9d05-b7f58b487980">

(그림 출처: 이것이 취업을 위한 컴퓨터 과학이다)

## DMA 입출력

- 프로그램 기반의 입출력과 인터럽트 기반의 입출력에 공통점이 있다면 CPU가 입출력장치와 메모리간의 데이터 이동을 주도해야하며, 이동하는 데이터들도 반드시 CPU를 거친다는 점.
-  예를 들어, 입출력장치의 데이터를 메모리에 저장하는 경우, CPU는 장치 컨트롤러로부터 데이터를 하나씩 읽어 레지스터에 적재하고, 적재한 데이터를 하나씩 메모리에 저장해야 함.
- 메모리 속 데이터를 입출력장치에 내보내는 경우도 마찬가지임. CPU는 메모리로부터 데이터를 하나씩 읽어 레지스터에 적재하고, 적재한 데이터를 하나씩 입출력장치에 내보내야 합니다.

![image-20241112201035714](/Users/myungsun/Library/Application Support/typora-user-images/image-20241112201035714.png)

(그림 출처: 이것이 취업을 위한 컴퓨터 과학이다)

이처럼 입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거쳐야 한다면 CPU의 부담이 커질 것임. 그래서 CPU를 거치지 않고도 입출력장치와 메모리가 상호작용할 수 있는 입출력 방식인 **DMA(Direct Memory Access)**가 등장함.

- DMA는 이름 그대로 **직접 메모리에 접근할 수 있는 입출력 기능**을 말함
- DMA 입출력을 위해서는 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요함. DMA 컨트롤러가 포함될 경우 DMA 입출력은 대략 다음과 같은 구조로 구성됨.
  - DMA 컨트롤러는 시스템 버스에 연결되고, 입출력장치들의 장치 컨트롤러들은 입출력 버스(input/output but)라는 입출력장치 컨트롤러의 전용 버스와 연결됨

<img width="805" alt="image" src="https://github.com/user-attachments/assets/fbb5bcf7-6182-4294-bb05-340793242b86">

(그림 출처: 이것이 취업을 위한 컴퓨터 과학이다)

- 일반적인 DMA 입출력은 다음과 같은 과정으로 이루어짐
  1. CPU가 DMA 컨트롤러에게 입출력장치의 주소, 수행할 연산, 연산할 메모리 주소 등의 정보와 함께 **입출력 작업을 명령**함
  2. DMA 컨트롤러가 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행함. 이 때, DMA 컨트롤러는 필요한 경우, 메모리에 직접 접근하여 정보를 읽거나 쓴다. 입출력장치와 메모리 사이에 주고 받을 데이터가 CPU를 거치지 않음
  3. DMA 컨트롤러는 입출력 작업이 끝나면 CPU에게 인터럽트를 걸어 작업이 끝났음을 알림.
- CPU 입장에서는 DMA 컨트롤러에게 입출력 작업 명령을 내리고, 인터럽트만 받으면 되기 때문에 입출력 부담을 크게 줄일 수 있음.

<br/>

<br/>

오늘 공부한 내용은 여기까지 입니다.

읽어주셔서 감사합니다.