# 2024-11-17-TIL

안녕하세요.

오늘은 11월 4주차동안 공부한 것들에 대한 복습을 해보도록 하겠습니다.

# 보조기억장치와 입출력장치

- 보조기억장치는 메모리의 휘발성을 보완하는 동시에, 메모리보다 큰 저장 공간을 제공함

## RAID

- 오늘날 대중적으로 활용되고 있는 보조기억장치는 크게 2가지

  - 하드 디스크 드라이브(이하 하드 디스크)(HDD, Hard Disk Drive)
    - 자기적인 방식으로 데이터를 읽고 쓰는 보조기억장치

  

  <img width="333" alt="image" src="https://github.com/user-attachments/assets/9c01ae84-26d2-4727-87e6-a7fefa79bdd6">

  (그림 출처: 이것이 취업을 위한 컴퓨터과학이다)

  - 플래시 메모리 기반 저장장치
    - 전기적인 방식으로 데이터를 읽고 쓰는 반도체 기반의 저장장치
    - 우리가 흔히 사용하는 USB 메모리나 SD카드, SSD가 모두 플래시 메모리 기반 저장장치라고 할 수 있으며, 이 중 보조기억장치로 주로 사용되는 플래시 메모리는 **SSD(Solid-State Drvie)**임.

- 보조기억장치의 역할

  - 전원이 꺼져도 데이터를 안전하게 보관하는 것
  - CPU가 필요로 하는 정보를 조금이라도 빠른 성능으로 메모리에 전달하는 것. 즉, 보조기억장치의 데이터를 안전하고 빠르게 다룰 수 있는 방법이 중요한 것. 이를 위해 사용할 수 있는 기술이 **RAID(Redundant Array of independent Disks)**

- **RAID(Redundant Array of independent Disks)**

  - 데이터의 안전성 혹은 성능을 확보하기 위해 여러 개의 독립적인 보조기억장치를 마치 하나의 보조기억장치처럼 사용하는 기술을 의미
  - 앞서 설명한 하드 디스크나 SSD로 RAID를 구성할 수 있음

### RAID를 구성하는 방법

- RAID를 구성하는 방법에는 여러 가지가 있으며 RAID 레벨이라고 표현함.
- RAID0, RAID1, RAID2, RAID3, RAID4, RAID5, RAID6이 대표적이며, 그로부터 RAID10, RAID50 등이 파생되었음.

#### RAID0

- 데이터를 여러 보조기억장치에 단순하게 나누어 저장하는 구성 방식

<img width="834" alt="image" src="https://github.com/user-attachments/assets/dbfcc31d-9020-4aa5-83d1-20b485ba9c9b">

(그림 출처: 이것이 취업을 위한 컴퓨터과학이다)

- 저장되는 데이터가 하드 디스크의 개수만큼 나뉘어 저장되어 있음
- 마치 줄무니처럼 분산되어 저장된 데이터를 스트라입(stripe)이라고 하고, 이렇게 분산하여 저장하는 동작을 **스트라이핑(striping)**이라고 함.
- RAID0의 **장점**은 빠른 입출력 속도임. 하나의 대용량 저장장치를 이용했다면 여러 번에 걸쳐서 읽고 써야 했을 데이터를 한 번에, 동시에 읽고 쓸 수 있기 때문임. 
  - 가령 위 그림과 같이 저장된 상태에서 데이터 A1, A2, A3, A4를 동시에 읽어 들이면 하드 디스크 1~4에서 동시에, 한 번에 읽어들일 수 있음. 그렇기 때문에 4TB인 저장장치 1개를 읽고 쓰는 속도보다 RAID0으로 구성된 1TB인 저장장치 4개의 속도가 이론상 4배 가량 빠름
- RAID0의 **단점**은 **저장된 정보가 안전하지 않다는 것**임. 만약, 위 그림의 하드 디스크1에 문제가 생긴다면 하드 디스크2, 3, 4에 저장된 데이터는 불완전한 데이터가 됩니다.

#### RAID1

- **완전한 복사본을 만들어 저장하는 구성 방식**. 그래서 미러링(mirroring)이라고도 부름
- RAID1은 복구가 간단하고 안전성이 높다는 장점이 있음
  - 다만, RAID1에 어떤 데이터를 쓸 때는 원본과 복사본 두 곳에 써야하기 때문에 RAID0보다 쓰기 속도가 느려집니다.
  - RAID1은 복사본이 저장된 크기만큼 **사용 가능한 용량이 적어진다**는 단점도 있음

<img width="787" alt="image" src="https://github.com/user-attachments/assets/5ec3dd43-ee8c-45db-b9ef-851fdec177c7">

(그림 출처: 이것이 취업을 위한 컴퓨터과학이다)

#### RAID4

- 패리티 정보를 저장하는 디스크를 따로 두는 구성 방식
  - **패리티** => 오류를 검출할 수 있는 정보를 말함
- RAID4를 통해 오류 검출용 장치를 따로 두면 RAID1에 비해 적은 하드 디스크로도 안전하게 데이터를 보관할 수 있음
- RAID4 단점
  - 패리티를 저장하는 장치에 병목 현상이 발생한다는 것.
  - 어떤 새로운 데이터가 저장될 때마다 패리티를 저장하는 디스크에도 데이터를 쓰게 되므로 하드 디스크4에도 쓰기 작업을 해야 함. 굉장히 바빠진 하드 디스크4가 병목 지점이 될 수 있다는 것

<img width="820" alt="image" src="https://github.com/user-attachments/assets/ea6b78db-e944-4cf0-a6a6-e641a009f8de">

(그림 출처: 이것이 취업을 위한 컴퓨터과학이다)

#### RAID5

- **패리티를 분산하여 저장하는 구성 방식**
- 다음과 같이 패리티를 분산 저장하면 RAID4의 단점인 병목 현상을 보완할 수 있음

<img width="645" alt="image" src="https://github.com/user-attachments/assets/5e1a3c2a-0a69-494c-8a13-64d4d0695a64">

(그림 출처: 이것이 취업을 위한 컴퓨터과학이다)

#### RAID6

- RAID6 구성은 기본적으로 RAID5와 같지만, 다음과 같이 **서로 다른 2개의 패리티를 두는 구성 방식**임
- **오류를 검출하고 복구할 수 있는 수단이 2개가 생긴 셈**
- 따라서, RAID6은 RAID4나 RAID5에 비해 안정성이 높음. 다만, 새로운 정보를 저장할 때마다 저장할 패리티가 2개이므로 RAID5에 비해 쓰기 속도는 일반적으로 느림

<img width="794" alt="image" src="https://github.com/user-attachments/assets/2cf51711-9ba5-43c4-9a7c-fbde8e9ecec9">

(그림 출처: 이것이 취업을 위한 컴퓨터과학이다)

---

이처럼 RAID 레벨마다 각기 다른 장단점이 있기 때문에 어떤 상황에서 무엇을 최우선으로 원하는 지에 따라 최적의 RAID 레벨의 대략적인 구성과 특징을 알고 있는 것이 중요함.

---

# 입출력 기법

## 장치 컨트롤러와 장치 드라이버

- 다양한 외부 장치가 컴퓨터 내부와 어떻게 연결되고 소통되는지를 알기 위해서는 우선 **장치 컨트롤러(device controller)**와 **장치 드라이버(device driver)**라는 개념을 알아야 함.
- 같은 입출력장치라 하더라도 제조사마다 규격과 작동 방식이 상이할 수 있어, CPU 입장에서 모든 입출력장치의 작동 방식을 아는 것은 어려운 일입니다. 따라서, 입출력장치는 CPU와 직접 연결되어 정보를 주고받지 않고, 장치 컨트롤러라는 하드웨어를 통해 연결됨. 모든 입출력장치는 각자의 장치 컨트롤러를 통해 컴퓨터 내부와 연결되어 정보를 주고받음
- 즉, 장치 컨트롤러는 CPU와 입출력장치 사이의 통신을 중개하는 중개자 역할의 하드웨어인 셈. CPU가 직접 하드 디스크를 회전시키거나 마이크의 입력 값을 해석하고, 프린트를 작동시키는 것이 아니라, 장치 컨트롤러의 중개를 통해 입출력장치가 작동하는 것임.
  - 참고로, 장치 컨트롤러에는 RAM과 같은 저장장치가 있는 경우가 많음. CPU와 정보를 주고받는 과정에서 기억해야 하는 많은 중간 값들이 장치 컨트롤러의 저장장치에 저장됨. 이 저장장치 역시 휘발성인 경우가 많아, 입출력 작업 도중에 연결을 해제하거나 연결된 장치를 안전 제거하지 않으면 입출력 데이터에 문제가 발생할 수 있음
- CPU가 실행하는 것은 결국 프로그램. 그리고 CPU는 장치 컨트롤러와 상호작용하며 입출력장치를 작동시킴. 이는 CPU가 장치 컨트롤러와 상호작용함으로써 입출력장치를 작동시키는 것 또한 CPU가 실행하는 프로그램을 통해 이루어진다는 말과 같음.
- 바로 이 프로그램이 **장치 드라이버**임. 일반적으로 장치 컨트롤러마다 이를 작동시키는 장치 드라이버라는 프로그램이 있음. 장치 드라이버란 **장치 컨트롤러의 동작을 알고, 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있도록 하는 프로그램**임.
- 컴퓨터가 장치 드라이버를 인식하지 못한다면 장치 컨트롤러와 정보를 주고받는 방법을 알 수 없으므로 입출력장치를 실행하지 못할 것임.



## 프로그램 입출력(Programmed I/O)

- **프로그램 속 명령어로 입출력 작업을 수행하는 방법**
- CPU는 "프린터 컨트롤러의 상태를 확인하라", "하드 디스크 컨트롤러에 10을 써라"와 같은 입출력 명령어를 실행함으로써 장치 컨트롤러와 상호작용할 수 있고, 이를 통해 입출력 작업을 수행함.

## 인터럽트 기반 입출력: 다중 인터럽트

- 키보드, 마우스 모니터, 스피커 등의 입출력장치를 동시에 사용하는 상황을 생각해보자. 이 경우에 CPU는 동시 다발적으로 발생하는 키보드, 마우스, 모니터, 스피커 인터럽트를 모두 처리해야 함.

- 이렇게 인터럽트가 여러 입출력장치로부터 동시다발적으로 발생하는 경우에는 어떻게 인터럽트를 처리해야 할까?

  - CPU가 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리할 경우, 다른 하드웨어 인터럽트를 받아들이지 않기 때문에 CPU는 기본적으로 다음과 같이 인터럽트가 발생한 1~8의 순서대로 인터럽트 서비스 루틴을 순차적으로 실행하게 됨.
  - 하지만, 모든 인터럽트가 아래 그림과 같이 처리되지는 않음. 인터럽트 중에서도 우선순위가 더 높은 인터럽트가 우선적으로 처리되는 경우가 일반적임. 예를 들어, 현재 CPU가 인터럽트 A를 처리하는 도중에 또 다른 인터럽트 B가 들어왔다고 가정해보자.

  <img width="428" alt="image" src="https://github.com/user-attachments/assets/ae00f102-f536-465a-8c5e-cb887f884474">

  (그림 출처: 이것이 취업을 위한 컴퓨터 과학이다)

  - 만약, 지금 처리중인 인터럽트 A보다 B의 우선순위가 높다면, CPU는 인터럽트 A의 실행을 잠시 멈추고 B를 처리한 뒤에 다시 A를 처리함. 반대로 인터럽트 A보다 B의 우선순위가 낮다면, CPU는 인터럽트 A를 모두 처리한 뒤에 B를 처리함.

- CPU는 플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우, 혹은 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트인 NMI(Non-Maskable Interrupt)가 발생한 경우, 이렇게 우선순위가 높은 인터럽트부터 먼처 처리하게 됨

- 흔히 다중 인터럽트를 처리하기 위해서는 **프로그래머블 인터럽트 컨트롤러(이하 PIC)(Programmable Interrupt Controller)**라는 하드웨어가 사용됨.

- PIC는 여러 장치 컨트롤러에 연결되어 있어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤, CPU에게 지금 처리해야 할 하드웨어 인터럽트가 무엇인지를 알려주는 장치임.

<img width="839" alt="image" src="https://github.com/user-attachments/assets/cb4bddf9-5975-4b34-9d05-b7f58b487980">

(그림 출처: 이것이 취업을 위한 컴퓨터 과학이다)

## DMA 입출력

- 프로그램 기반의 입출력과 인터럽트 기반의 입출력에 공통점이 있다면 CPU가 입출력장치와 메모리간의 데이터 이동을 주도해야하며, 이동하는 데이터들도 반드시 CPU를 거친다는 점.
- 예를 들어, 입출력장치의 데이터를 메모리에 저장하는 경우, CPU는 장치 컨트롤러로부터 데이터를 하나씩 읽어 레지스터에 적재하고, 적재한 데이터를 하나씩 메모리에 저장해야 함.
- 메모리 속 데이터를 입출력장치에 내보내는 경우도 마찬가지임. CPU는 메모리로부터 데이터를 하나씩 읽어 레지스터에 적재하고, 적재한 데이터를 하나씩 입출력장치에 내보내야 합니다.

![image-20241112201035714](/Users/myungsun/Library/Application Support/typora-user-images/image-20241112201035714.png)

(그림 출처: 이것이 취업을 위한 컴퓨터 과학이다)

이처럼 입출력장치와 메모리 사이에 전송되는 모든 데이터가 반드시 CPU를 거쳐야 한다면 CPU의 부담이 커질 것임. 그래서 CPU를 거치지 않고도 입출력장치와 메모리가 상호작용할 수 있는 입출력 방식인 **DMA(Direct Memory Access)**가 등장함.

- DMA는 이름 그대로 **직접 메모리에 접근할 수 있는 입출력 기능**을 말함
- DMA 입출력을 위해서는 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요함. DMA 컨트롤러가 포함될 경우 DMA 입출력은 대략 다음과 같은 구조로 구성됨.
  - DMA 컨트롤러는 시스템 버스에 연결되고, 입출력장치들의 장치 컨트롤러들은 입출력 버스(input/output bus)라는 입출력장치 컨트롤러의 전용 버스와 연결됨

<img width="805" alt="image" src="https://github.com/user-attachments/assets/fbb5bcf7-6182-4294-bb05-340793242b86">

(그림 출처: 이것이 취업을 위한 컴퓨터 과학이다)

- 일반적인 DMA 입출력은 다음과 같은 과정으로 이루어짐
  1. CPU가 DMA 컨트롤러에게 입출력장치의 주소, 수행할 연산, 연산할 메모리 주소 등의 정보와 함께 **입출력 작업을 명령**함
  2. DMA 컨트롤러가 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행함. 이 때, DMA 컨트롤러는 필요한 경우, 메모리에 직접 접근하여 정보를 읽거나 쓴다. 입출력장치와 메모리 사이에 주고 받을 데이터가 CPU를 거치지 않음
  3. DMA 컨트롤러는 입출력 작업이 끝나면 CPU에게 인터럽트를 걸어 작업이 끝났음을 알림.
- CPU 입장에서는 DMA 컨트롤러에게 입출력 작업 명령을 내리고, 인터럽트만 받으면 되기 때문에 입출력 부담을 크게 줄일 수 있음.

---

# 운영체제의 역할

- 운영체제의 핵심 기능을 담당하는 부분을 커**널(Kernel)**이라고 함
- 커널은 마치 자동차의 엔진이나 사람의 심장과도 같은 핵심부라고 할 수 있음.

<img width="532" alt="image" src="https://github.com/user-attachments/assets/245867ee-9a47-490b-8e2b-722089e74e6b">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다)

- 운영체제에는 크게 2가지 핵심 기능이 있음 
  1. 자원 할당 및 관리
     - 자원 또는 시스템 자원이란 프로그램 실행에 마땅히 필요한 요소를 의미
     - 실행에 필요한 '데이터'를 자원(소프트웨어)이라고 하기도 하고, 실행에 필요한 '부품'을 자원(하드웨어)이라고 하기도 함.
     - 운영체제는 사용자가 실행하는 응용 프로그램을 대신하여 CPU, 메모리, 보조기억장치 등의 컴퓨터 부품에 접근하고, 각각의 부품들이 효율적으로 사용되도록 관리함.
     - 또 응용 프로그램이 컴퓨터 부품들을 효율적으로 할당받아 문제 없이 실행할 수 있도록 응용 프로그램에 자원을 할당함.
  2. 프로세스 및 스레드 관리
- 운영체제의 큰 그림 

<img width="481" alt="image" src="https://github.com/user-attachments/assets/589e4be7-c2e7-46b1-9432-d127f130d583">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다)

## CPU 관리: CPU 스케줄링

- 메모리에는 실행 중인 프로그램이 다수 적재될 수 있지만, CPU가 이들 모두를 동시에 실행할 수 있는 것은 아님.
- CPU는 한정된 자원이기 때문에 CPU를 할당받아 사용하기 위해 때로는 다른 프로그램의 CPU 사용이 끝날 때까지 기다려야 함.
- 그래서 운영체제는 실행 중인 모든 프로그램들이 공정하고 합리적으로 CPU를 할당받도록 CPU의 할당 순서와 사용 시간을 결정함.

<img width="574" alt="image" src="https://github.com/user-attachments/assets/cfff3bfa-0ba9-4268-bb2f-66971943b0a9">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다)

## 메모리 관리: 가상 메모리

- 운영체제는 새롭게 실행하는 프로그램을 메모리에 적재하고, 종료된 프로그램을 메모리에서 삭제함.
- 동시에 낭비되는 메모리 용량이 없도록 효율적으로 관리해야 함.
- 오늘날 존재하는 많은 운영체제들은 이를 위해 가상 메모리 기술을 활용
- 가상 메모리는 운영체제의 메모리 관리 기법 중 하나로, 실제 물리적인 메모리 크기보다 더 큰 메모리를 이용할 수 있도록하는 기술

<img width="417" alt="image" src="https://github.com/user-attachments/assets/93e5bddc-d800-460d-b930-d36e725d8ae9">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다)

## 파일/디렉터리 관리: 파일 시스템

- 메모리보다 더 큰 용량을 갖고 있는 보조기억장치는 더욱 일목요연하게 관리할 필요가 있음
- 보조기억장치에 아무렇게나 정보를 저장한다면 마치 어질러진 서랍에 원하는 물건을 찾듯 원하는 정보에 접근하기 위해 오랜 시간이 소요되기 때문.
- 운영체제는 보조기억장치를 효율적으로 관리하기 위해 파일 시스템을 활용함.
- 파일 시스템은 보조기억장치 내의 정보를 파일 및 폴더(디렉터리) 단위로 접근 관리할 수 있도록 만드는 운영체제 내부 프로그램임.

<img width="367" alt="image" src="https://github.com/user-attachments/assets/7a4976f2-de25-4e41-ade0-71533fda973e">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다)

## 프로세스 및 스레드 관리

- 지금까지 우리가 단순히 '실행 중인 프로그램'이라고 지칭했던 대상은 **프로세스(process)**라고 함.
- 그리고 **스레드(thread)**는 이 프로세스를 이루는 실행의 단위.
- 메모리에는 여러 프로세스가 적재될 수 있는데, 운영체제는 이 프로세스에 필요한 자원을 할당하고, 스레드는 프로세스가 할당받은 자원을 이용해 프로세스의 작업을 수행함.
- 프로세스를 이루는 스레드가 둘 이상인 경우에는 동일한 작업을 동시에 실행할 수도 있음.

<img width="625" alt="image" src="https://github.com/user-attachments/assets/64b5e121-fb9f-4dd8-ad0a-79bae04f9b1f">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다)

- 운영체제는 이렇게 동시다발적으로 실행되는 프로세스와 스레드가 올바르게 처리되도록 실행의 순서를 제어하고, 프로세스와 스레드가 요구하는 자원을 적절하게 배분할 수 있어야 함.

![image-20241113195208612](/Users/myungsun/Library/Application Support/typora-user-images/image-20241113195208612.png)

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다)

## 정리

<img width="871" alt="image" src="https://github.com/user-attachments/assets/55fb3c2e-982a-43cb-8b36-96d014b1afd6">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다)

----

# 시스템 콜과 이중모드 

- 운영체제도 일종의 프로그램이기 때문에 프로그램이 실행되기 위해서는 반드시 메모리에 적재되어야 함.
- 다만, 사용자 프로그램과 달리 운영체제는 매우 특별한 프로그램이므로 메모리 내의 **커널 영역(Kernel Space)**이라는 공간에 따로 적재되어 실행됨.
- 다음과 같이 운영체제가 적재되는 커널 영역 외에 사용자 응용 프로그램이 적재되는 공간은 **사용자 영역(user space)**이라고 함.
- 우리가 주목해야할 점은 '운영체제의 기능을 제공받기 위해서는 커널 영역에 적재된 운영체제 코드를 실행해야 한다'는 점임.

<img width="293" alt="image" src="https://github.com/user-attachments/assets/fcfaebd6-8535-4e56-b099-e914cae0fab3">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

- 일반적으로 웹 브라우저나 게임과 같은 (사용자) 응용 프로그램은 운영체제와 달리 CPU, 메모리와 같은 자원에 직접 접근하거나 조작할 수 없음. 특정 자원에 접근하거나 조작하는 운영체제 코드를 실행해야 함. 즉, 운영체제가 자신의 코드를 실행한 응용 프로그램의 자원 접근 및 조작을 대행하는 셈.

## 응용 프로그램은 어떻게 운영체제의 코드를 실행할까?

- 응용 프로그램은 **시스템 콜(system call)**을 호출하여 운영체제 코드를 실행할 수 있음.
- 시스템 콜을 운영체제의 서비스를 제공 받기 위한 수단(인터페이스)으로, 호출 가능한 함수의 형태를 가짐.
- 응용 프로그램이 운영체제로부터 어떤 기능을 제공받고자 한다면 다음과 같이 그 기능에 해당하는 시스템 콜을 호출하면 됨.

![image-20241114194227484](/Users/myungsun/Library/Application Support/typora-user-images/image-20241114194227484.png)

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

- 운영체제에 따라 제공하는 시스템 콜의 종류와 개수는 다야함. 다음은 유닉스 계열의 운영체제에서 사용하는 대표적인 시스템 콜의 종류임.

<img width="815" alt="image" src="https://github.com/user-attachments/assets/3aa5722b-55b4-4e52-b85d-2e4f6def0049">

<img width="814" alt="image" src="https://github.com/user-attachments/assets/1d9e02f8-03bf-4a5b-8fa3-14e2839377e2">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

## 컴퓨터 내부에서 시스템 콜이 호출되면 발생하는 작업들

<img width="808" alt="image" src="https://github.com/user-attachments/assets/59fbbbdd-4901-4f0e-bd0f-6b0e424d0bb3">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

- 운영체제에는 인터럽트를 발생시키는 특정 명령어가 있음.
- 자원에 접근하는 입출력 명령어가 대표적이며, 이러한 명령어에 의해 발생하는 인터럽트를 **소프트웨어 인터럽트(software interrupt)**라고 함.
- 시스템 콜이 바로 이 소프트웨어 인터럽트의 일종임.
- 따라서, 사용자 영역을 실행하는 과정에서 시스템 콜이 호출되면 여느 인터럽트와 마찬가지로 CPU는 현재 수행 중인 작업을 백업하고, 커널 영역 내의 인터럽트를 처리하기 위한 코드 (시스템 콜을 구성하는 코드)를 실행한 뒤, 다시 사용자 영역의 코드 실행을 재개함.

<img width="539" alt="image" src="https://github.com/user-attachments/assets/7b28ac74-f963-4ee0-81e9-927328ab3e78">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

- CPU는 명령어를 실행하는 과정에서 사용자 영역을 실행할 때의 모드와 커널 영역을 실행할 때의 모드를 구분하여 실행함.
- 이때, 사용자 영역에 적재된 코드를 실행할 때의 실행 모드를 **사용자 모드(user mode)**라 하고, 커널 영역에 적재된 코드를 실행할 때의 실행 모드를 **커널 모드(kernel mode)**라 함. 그리고 이렇게 2개의 모드로 구분하여 실행하는 것을 **이중 모드(dual mode)**라고 함.
- **사용자 모드**는 운영체제 서비스를 제공받을 수 없는 실행 모드로, 커널 영역의 코드를 실행할 수 없는 모드임. 사용자 모드로 실행중인 CPU는 입출력 명령어와 같이 자원에 접근하는 명령어를 만나도 이를 실행하지 않음. 덕분에 사용자 모드로 실행되는 명령어는 실수로라도 자원에 접근할 수 없음.
- 반면, **커널 모드**는 운영체제 서비스를 제공받을 수 있는 실행 모드로, 커널 영역의 코드를 실행할 수 있는 모드임. CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 명령어를 비롯한 모든 명령어를 실행할 수 있음.

---

# 프로세스와 스레드

- 메모리에는 컴퓨터가 실행되는 순간부터 다양한 프로세스들이 적재되어 실행됨.
- 프로세스의 유형으로는 사용자가 보는 공간에서 사용자와 상호작용하며 실행되는 **포그라운드 프로세스(foreground process)**도 있고, 사용자가 보지 못하는 곳에서 실행되는 **백그라운드 프로세스(background process)**도 있음
- 백그라운드 프로세스 중에서도 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스인 **데몬(daemon)**도 있음. 윈도우 운영체제에서는 데몬을 서비스(service)라고 부름
- 하지만, 프로세스의 유형을 막론하고 하나의 프로세스를 구성하는 메모리 내의 정보는 크게 다르지 않음.
- 다음과 같이 커널 영역에는 프로세스 제어 블록(PCB)이라는 정보가 저장되고, 사용자 영역에는 실행 중인 프로세스가 코드 영역, 데이터 영역, 힙 역역, 스택 영역으로 나뉘어 저장됨.
  - 코드 영역
    - 실행 가능한 명령어가 저장되는 공간으로, 텍스트 영역(text segment)이라고도 부름
    - CPU가 읽고 실행할 명령어가 담겨 있기 때문에 쓰기가 금지되어 있는 읽기 전용(read-only) 공간임.
  - 데이터 영역
    - 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
    - 데이터 영역에 저장되는 데이터는 **정적 변수**나 **전역 변수**가 대표적
    - 코드 영역과 데이터 영역은 프로그램 실행 도중 크기가 변하지 않기 때문에 **정적 할당 영역**이라고 부름
    - 반면에, 크기가 변할 수 있는 힙 영역과 스택 영역은 **동적 할당 영역**이라고 부름
  - 힙 영역
    - 프로그램을 만드는 사용자(개발자)가 직접 할당 가능한 저장 공간
    - 프로그램 실행 도중 비교적 자유롭게 할당하여 사용 가능한 메모리 공간이라 볼 수 있음
    - 다만, 힙 영역에 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야 함.
    - 메모리 공간을 반환하지 않으면 할당한 공간이 계속 메모리 내에 남아 메모리를 낭비하는 **메모리 누수(memory leak)**문제를 초래할 수 있음.
    - 때로는 이러한 문제를 해결하기 위해 프로그래밍 언어에서 자체적으로 사용되지 않은 힙 메모리를 해제하는 **가비지 컬렉션(garbage collection)** 기능을 제공하기도 함.
  - 스택 영역
    - 데이터 영역에 담기는 값과는 달리 일시적으로 사용할 값들이 저장되는 공간.
    - 함수의 실행이 끝나면 사라지는 **매개변수, 지역 변수, 함수 복귀 주소** 등이 스택 영역에 저장되는 대표적인 데이터들임.
    - 스택 트레이스 형태의 함수 호출 정보가 저장될 수 있다는 점을 기억해야 함.
    - 스택 트레이스(stack trace)란 특정 시점에 스택 영역에 저장된 함수 호출 정보를 말함.
    - 스택 트레이스로는 문제의 발생 지점을 추적할 수 있어, 디버깅에 매우 유용하게 사용됨

<img width="491" alt="image" src="https://github.com/user-attachments/assets/0dfb4d95-ac47-45be-8d08-5e1a09feab09">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

## PCB와 문맥 교환 

- 운영체제가 메모리에 적재된 다수의 프로세스를 관리하려면 프로세스를 식별할 수 있는 커널 영역 내의 정보가 필요.
- 이 정보가 바로 **프로세스 제어 블록(이하 PCB)(Process Control Block)**
- PCB는 프로세스와 관련한 다양한 정보를 내포하는 구조체의 일종으로, 새로운 프로세스가 메모리에 적재(프로세스 생성)됐을 때 커널 영역에 만들어지고, 프로세스의 실행이 끝나면 폐기됨.
- PCB에 담기는 정보는 운영체제마다 차이가 있지만, 대표적으로 프로세스 식별 번호인 **프로세스 ID(이하 PID)**와 프로세스가 **실행 과정에서 사용한 레지스터 값**, 프로세스가 현재 어떤 상태인지를 나타내는 **프로세스 상태**, 프로세스가 언제, 어떤 순서로 CPU를 할당받을지 나타내는 **CPU 스케줄링(우선순위)정보**, 프로세스의 메모리상 적재 위치를 알 수 있는 **메모리 관련 정보**, 프로세스가 사용한 **파일 및 입출력장치 관련 정보**가 명시됨
- 이때 여러 PCB들은 커널 내에 **프로세스 테이블(process table)**의 형태로 관리되는 경우가 많음.
- 프로세스 테이블은 실행 중인 PCB의 모음을 의미함.
- 새롭게 실행되는 프로세스가 있다면 해당 프로세스의 PCB를 프로세스 테이블에 추가하고, 필요한 자원을 할당함. 반대로, 종료되는 프로세스가 있다면 사용 중이던 자원을 해제하고 PCB도 프로세스 테이블에서 삭제됨
  - 프로세스가 비정상 종료되어 사용한 자원이 회수되었음에도 프로세스 테이블에 종료된 프로세스의 PCB가 남아 있는 경우가 있음. 이러한 비정상 종료 상태를 **좀비 프로세스(zombie process)**라고 함.

<img width="450" alt="image" src="https://github.com/user-attachments/assets/95dfb411-e349-4000-a0c8-77ad9cf1fc0f">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

- 일반적으로 메모리에 적재된 프로세스들은 한정된 시간 동안 번갈아 가며 실행됨.
- 이때, **프로세스가 실행된다**는 말은 **운영체제에 의해 CPU의 자원을 할당받았다는 말과 같음.**
- CPU가 프로세스를 구성하는 명령어와 데이터를 인출하여 실행하고, 운영체제가 CPU 자원을 할당하기 때문. 즉, '다양한 프로세스들이 한정된 시간 동안 번갈아 가며 실행된다'는 말은 '다양한 프로세스들이 한정된 시간 동안 운영체제로부터 CPU의 자원을 번갈아 가며 할당받아서 이용한다'는 말과 같음
- 프로세스의 CPU 사용 시간은 타이머 인터럽트에 의해 제한됨.
  - 타이머 인터럽트 => 시간이 끝났음을 알리는 인터럽트로, 타임아웃 인터럽트라고도 부름
- 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다림. 
- 예를 들어, 다음과 같이 프로세스 A가 운영체제로부터 CPU를 할당받아 실행되다가, 타이머 인터럽트가 발생하여 프로세스 B로 CPU 사용을 양보한다고 가정
  - 이 때 프로세스 A는 프로그램 카운터를 비롯한 각종 레지스터 값과 메모리 정보, 실행을 위해 열었던 파일, 사용한 입출력장치 등 지금까지의 중간 정보를 **백업**해야 함. 그래야 다음에 다시 프로세스 A를 실행할 차례가 되었을 때 이전까지 실행했던 내용은 이어서 재개할 수 있음.
  - 여기서 백업 대상이 되는 중간 정보, 즉 프로세스의 수행을 재개하기 위해 기억해야 할 정보를 **문맥(context)**이라고 함.
  - 프로세스의 문맥은 해당 프로세스의 PCB에 명시됨.
  - 프로세스가 CPU를 사용할 수 있는 시간이 다 되거나 인터럽트가 발생하면 **운영체제는 해당 프로세스의 PCB에 문맥을 백업**함. 그리고 뒤이어 **실행할 프로세스의 문맥을 복구**함.
  - 이처럼 기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 새로운 프로세스를 실행하는 것을 **문맥 교환(context switching)**이라고 함.
    - 문맥 교환은 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리
- 언뜻 보면 프로세스를 자주 번갈아 가며 수행할수록 많은 프로세스를 동시에 실행할 수 있어 좋을 것이라고 생각할 수도 있지만, 사실은 그렇지 않음. 프로세스 간에 너무 잦은 문맥교환이 발생하면 캐시 미스가 발생할 가능성이 높아져 메모리로부터 실행할 프로세스의 내용은 가져오는 작업이 빈번해지고, 이는 큰 오버헤드로 이어질 수 있음

<img width="510" alt="image" src="https://github.com/user-attachments/assets/4249d846-8c84-4073-b001-8f359f9d2f3b">

<img width="597" alt="image" src="https://github.com/user-attachments/assets/33575099-6368-4a8a-a37d-5cf3bdc648c6">

<img width="610" alt="image" src="https://github.com/user-attachments/assets/91b46975-ffde-40be-9ebd-d4670c826557">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

## 프로세스의 상태

- 하나의 프로세스는 여러 상태를 거치며 실행됨.
- 운영체제는 PCB를 통해 프로세스의 상태를 인식하고 관리함.
- 운영체제마다 프로세스의 상태를 표현하는 방식은 조금씩 차이가 있지만, 대표적인 상태로는 생성, 준비, 실행, 대기, 종료 등이 있음

<img width="615" alt="image" src="https://github.com/user-attachments/assets/9e9f73ab-8965-4e69-9033-3601cda30e41">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

## 블로킹 입출력과 논블로킹 입출력

- 블로킹 입출력
  - 프로세스가 실행 도중 입출력 작업을 수행해야 하는 상황을 생각해보자. 일반적으로 프로세스는 이 상황에서 대기 상태로 접어들고, 입출력 작업이 완료되면 준비 상태가 되어 실행을 재개함.
- 논블로킹 입출력
  - 입출력 작업을 수행할 모든 프로세스가 반드시 대기 상태에 접어들 필요는 없음.
  - 때로는 입출력장치에게 입출력 작업을 맡긴 뒤, 곧바로 이어질 명령어를 실행할 수도 있음.

<img width="321" alt="image" src="https://github.com/user-attachments/assets/53258a60-6fd8-4397-a34b-df21b5eac36b">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

 <br/>

<br/>

이번 주에 공부한 내용은 여기까지 입니다.

읽어주셔서 감사합니다.