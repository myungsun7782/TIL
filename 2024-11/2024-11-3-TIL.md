# 2024-11-3-TIL

안녕하세요.

오늘은 11월 1주차에 공부했던 내용들에 대해 복습해보도록 하겠습니다.

# 명령어

- 명령어는 수행할 동작과 수행할 대상으로 이루어짐
  - 수행할 대상
    - 수행할 동작에 사용될 데이터 자체가 될 수 있고
    - (메모리나 레지스터의 주소와 같이) 동작에 사용될 데이터가 저장될 위치(**오퍼랜드(operand)**)가 될 수도 있음
  - 수행할 동작
    - 명령어가 수행할 동작 => **연산 코드(opcode)**
- 하나의 명령어는 연산 코드와 0개 이상의 오퍼랜드로 구성되어 있으며, 명령어에서 연산 코드가 담기는 영역은 **연산 코드 필드**, 오퍼랜드가 담기는 영역은 **오퍼랜드 필드**라고 합니다.
  - 오퍼랜드 필드
    - 숫자나 문자와 같이 연산 코드에 사용될 데이터가 직접 명시되기보다는 많은 경우 **연산 코드에 사용될 데이터가 저장된 위치**, 즉, 메모리 주소나 레지스터의 이름이 명시된다는 점
    - **주소 필드(address field)**라고 부르기도 함.
    - 만약, 명령어에 사용된 오퍼랜드에 메모리 주소가 명시되었다면 이 명령어를 실행하기 위한 메모리 접근이 더 필요할 수 있음
    - 예를 들어, CPU가 메모리에 접근해 "곱해라 200번지 값에, 100을"이라는 명령어를 가지고 왔다고 가정해보면, CPU가 메모리로부터 인출한 명령어는 곧바로 실행될 수 없음. 이 명령어를 실행하려면 오퍼랜드 필드에 명시된 메모리 주소를 통해 한 번 더 메모리에 접근해야 함.
  - 연산 코드 필드
    - CPU에 따라 연산 코드의 구체적인 생김새가 다름.
    - 하지만, 대부분의 CPU가 공통적으로 이해하는 대표적인 연산 코드의 유형에는 **데이터 전송, 산술/논리 연산, 제어 흐름의 변경, 입출력 제어**가 있음

### 기계어와 어셈블리어

- CPU가 이해할 수 있도록 0과 1로 표현된 정보를 있는 그대로 표현한 언어를 "**기계어(machine code)**"라고 함
- 기계어만 봐서는 어떻게 동작되는지 쉽사리 짐작하기 어렵기 때문에 등장한 언어가 "**어셈블리어(assembly language)**"
  - 0과 1로 표현된 기계어를 읽기 편한 형태로 단순 번역한 언어
  - CPU가 이해할 수 있는 명령어의 종류와 동작을 파악할 수 있음
  - 0101 0101 => push rbp
  - 0101 1101 => pop rbp
- 같은 프로그램일지라도 CPU마다 이해하는 명령어가 다르면 실행이 불가할 수 있다는 점은 기억해야 함.
  - 예를 들어, 인텔 CPU를 사용하는 컴퓨터에서 만들어진 실행 파일을 애플 CPU를 사용하는 컴퓨터에 그대로 옮겨서 실행할 수 없음.

### 명령어 사이클

- 메모리 안에는 프로그램이 저장되어 있고, 이 프로그램은 여러 명령어로 구성되어 있음
- CPU는 이 메모리에서 명령어를 인출하고 실행하기를 반복하며 전체 프로그램을 실행해 나감
- **CPU가 명령어를 처리하는 과정에서 프로그램 속 각각의 명령어들은 일정한 주기를 반복하며 실행**되는데, 이 주기를 명령어 사이클(instruction cycle)이라고 함

#### 메모리에서 저장된 명령어 하나를 실행하고 싶을 때 가장 먼저 해야 할 일은 무엇일까?

- 명령어를 메모리에서 CPU로 가지고 와야(인출해야) 함. (= 인출 사이클(fetch cycle))
- CPU로 명령어를 인출했다면 이제는 그 명령어를 실행햐야 함. (= 실행 사이클(execution cycle))

위 2가지 과정은 계속 반복되는 사이클임.

하지만, 모든 명령어가 단순하게 위 2가지 과정만 반복하며 실행되지는 않음

명령어를 인출했더라도 곧바로 실행할 수 없는 경우도 있음

만약, 오퍼랜드 필드에 메모리 주소가 명시된 경우, CPU가 명령어를 인출했더라도 한 번 더 메모리에 접근해야 함.

이렇게 명령어를 실행하기 위해 한 번더 메모리에 접근하는 단계는 **간접 사이클(indirect cycle)**이라고 함

---

# 레지스터

- CPU 안에 있는 작은 임시 저장장치
- 프로그램을 이루는 데이터와 명령어가 프로그램의 실행 전후로 레지스터에 저장됨

앞으로 설명할 레지스터들은 **대부분의 CPU가 공통적으로 포함하고 있는 대표적인 주요 레지스터**입니다.

### 프로그램 카운터

**메모리에서 다음으로 읽어 들일 명령어의 주소를 저장**

- 프로그램 카운터를 **명령어 포인터**라고 부르는 CPU도 있음
- 일반적으로 프로그램 카운터는 1씩 증가하는데, 이는 곧 다음으로 읽어 들일 메모리 주소가 1씩 증가하는 것과 같음.
- 메모리에 저장된 프로그램이 순차적으로 실행될 수 있는 것은 근본적으로 프로그램 카운터 값이 1씩 증가하며 실행되기 때문
- 조건이 참이 되거나 리턴문을 실행하는 경우 프로그램이 순차적으로 실행되지 않고, 프로그램 카운터 값이 임의의 위치로 변경

### 명령어 레지스터

- **메모리에서 방금 읽어 들인 명령어를 저장하는 레지스터**
- CPU 내의 제어장치는 명령어 레지스터 속 명령어를 해석한뒤 ALU(산술논리연산장치)로 하여금 연산하도록 시키거나 다른 부품으로 제어 신호를 보내 해당 부품을 작동시킴

### 범용 레지스터

- 이름 그대로 다양하고 일반적인 상황속에서 자유롭게 사용할 수 있는 레지스터
- 데이터와 명령어, 주소 모두를 저장할 수 있음
- 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있음

### 플래그 레지스터

- 연산의 결과 혹은 CPU 상태에 대한 부가 정보인 플래그 값을 저장하는 레지스터
  - 플래그는 CPU가 명령어를 처리하는 과정에서 반드시 참조해야 할 상태 정보를 의미하는 비트

### 스택 포인터

- 메모리에 실행 중인 프로그램들이 적재되어 있으며, 실행 중인 각 프로그램들은 스택과 같은 형태로 사용 가능한 주소 공간을 하나 이상 가지고 있음
- 스택 포인터
  - 메모리 내 스택 영역의 최상단 스택 데이터 위치를 가리키는 특별한 레지스터
  - 마지막으로 스택에 저장된 데이터의 위치를 가리키는 레지스터
  - 스택이 채워진 정도를 나타내는 레지스터

---

# 인터럽트

- 인터럽트(interrupt)는 '방해하다', '중단시키다'라는 의미.
- **CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있는데, 이렇게 <u>CPU의 작업을 방해하는 신호</u>를 의미**

## 동기 인터럽트

- CPU에 의해 발생하는 인터럽트
- 예를 들어, CPU가 프로그래밍 오류와 같은 예외적인 상황(예상치 못한 상황)을 마주쳤을 때 발생하는 인터럽트
- 예외(exception)라고도 부름

### 예외

- 예외(동기 인터럽트)의 종류에는 폴트, 트랩, 중단, 소프트웨어 인터럽트 등이 있음
- CPU는 예외가 발생하면 하던 일을 중단하고, 해당 예외를 처리함.
- 그리고 예외를 처리하고 나면 다시 본래 하던 작업으로 되돌아와 실행을 재개
- CPU가 본래 하던 작업으로 되돌아왔을 때 **예외가 발생한 명령어**부터 실행하느냐, **예외가 발생한 명령어의 다음 명령어**부터 실행하느냐에 따라 **폴트**와 **트랩**으로 나눌 수 있음
  - 폴트
    - 예외를 처리한 직후에 예외가 발생한 명령어부터 실행을 재개하는 예외
    - 예를 들어, CPU가 명령어를 실행하려고 할 때, 명령어 실행을 위해 꼭 필요한 데이터가 메모리가 아닌 보조기억장치에 저장되어 있다고 가정해 보면, 프로그램이 실행되기 위해서는 데이터가 반드시 메모리에 저장되어 있어야 하므로 CPU는 폴트를 발생시키고, 보조기억장치로부터 필요한 데이터를 메모리로 가져와 저장하게 됨. CPU는 필요한 데이터를 보조기억장치로부터 메모리로 가져왔으므로 다시 실행을 재개해 폴트가 발생한 그 명령어부터 실행해 나갈 것임.
  - 트랩
    - 예외를 처리한 직후에 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
    - 대표적인 사례로 디버깅의 브레이크 포인트를 꼽을 수 있음
    - 프로그램을 중단시키고, 디버깅이 끝나면(트랩을 처리하고 나면) 트랩이 발생한 그 다음 명령어부터 실행해 나감.
  - 중단
    - CPU가 실행중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
  - 소프트웨어 인터럽트
    - 시스템 콜이 발생했을 때 발생하는 예외

## 비동기 인터럽트

- **주로 입출력장치에 의해 발생**하는 인터럽트
- 세탁기의 세탁 완료 알림, 전자레인지의 조리 완료 알림과 같은 **알림의 역할**
- CPU가 프린터와 같은 입출력장치에게 입출력 작업을 부탁하고, 작업을 끝낸 입출력장치가 CPU에게 **완료 알림(인터럽트)**을 보낸다.
- 키보드, 마우스와 같은 입출력 장치가 어떤 입력을 받아들였을 때, 이를 처리하기 위해 CPU에게 **입력 알림(인터럽트)**을 보낸다.
- **하드웨어 인터럽트**라고도 함

### 하드웨어 인터럽트

- CPU는 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용
- 예를 들어, CPU가 프린터에 프린트 명령어를 했다고 가정. 일반적으로 입출력장치의 속도는 CPU에 비해 현저히 느림. 그래서 CPU는 입출력 작업의 결과를 바로 받아볼 수 없음. 만약, 하드웨어 인터럽트를 사용하지 않는다면 CPU는 프린터가 언제 프린트를 끝낼지 모르기 때문에 주기적으로 프린터의 완료 여부를 확인해야 함
  - 폴링(Polling)
    - 입출력장치의 상태가 어떤지, 처리할 데이터가 있는지 주기적으로 확인하는 것을 말함
- 하드웨어 인터럽트를 사용하면 CPU는 작업이 끝나기를 마냥 기다릴 필요 없이 입출력장치가 진행되는 동안 온전히 다른 작업을 처리할 수 있게 됨
- 이렇듯 하드웨어 인터럽트는 입출력 완료 여부를 확인하기 위한 CPU 사이클 낭비를 최소화하고, CPU가 다른 일을 수행할 수 있는 시간을 벌어 줌으로서 효율적으로 명령어를 처리할 수 있도록 도움.
- CPU가 하드웨어 인터럽트를 처리하는 순서
  1. 입출력장치는 CPU에게 **인터럽트 요청 신호**를 보냄
     - CPU에게 인터럽트 가능 여부를 확인
  2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부를 확인함
  3. CPU는 인터럽트 요청을 확인하고, **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인함
     - 인터럽트 플래그 => 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그
  4. 인터럽트를 받아들일 수 있다면 CPU가 지금까지의 작업을 백업함
  5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행함
     - 인터럽트 서비스 루틴
       - 인터럽트를 처리하기 위한 프로그램으로, 인터럽트 핸들러(interrupt handler)라고도 부름
       - 인터럽트를 어떻게 처리하고, 작동해야 할지에 대한 정보로 이루어진 프로그램
       - CPU가 **인터럽트를 처리한다는 말은 인터럽트 서비스 루틴을 실행하고, 본래 작업으로 다시 되돌아온다**는 말과 같음
       - 입출력장치마다 인터럽트를 처리하기 위한 동작이 다르므로 입출력장치마다 각기 다른 인터럽트 서비스 루틴을 가지고 있음
       - 즉, 메모리에는 여러 개의 인터럽트 서비스 루틴들이 저장되어 있고, 이들 하나 하나가 '인터럽트가 발생하면 어떻게 행동해야 할지'를 알려주는 프로그램
     - 인터럽트 백터
       - 인터럽트 서비스 루틴을 식별하기 위한 정보
       - CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 버스를 통해 인터럽트 벡터를 전달받음
       - 인터럽트 서비스 루틴의 시작 주소를 포함하고 있기 때문에 CPU는 인터럽트 벡터를 통해 처음부터 특정 인터럽트 서비스 루틴을 실행할 수 있음.
  6. 인터럽트 서비스 루틴 실행이 끝나면 4번에서 백업해둔 작업을 복구하여 실행을 재개함

<img width="1266" alt="image" src="https://github.com/user-attachments/assets/ea895e50-b1b2-46a9-a330-268936cfc0d7">

<img width="917" alt="image" src="https://github.com/user-attachments/assets/21213525-9243-4a63-8bf1-336adb712b77">

<br/>

11월 1주차에 공부한 내용은 여기까지 입니다.

읽어주셔서 감사합니다.