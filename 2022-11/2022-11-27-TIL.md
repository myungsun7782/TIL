# 2022년 11월 27일(일)

---

### Today I Learned 

- [Design Pattern] **SingleTone Pattern** (Review)

---

## Singleton Pattern

> 애플리케이션이 시작될 떄, 어떤 클래스가 최초 한 번만 메모리를 할당(static)하고, 해당 메모리에 인스턴스트를 만들어 사용하는 패턴

- 즉, 싱글톤 패턴은 '하나'의 인스턴스만 생성하여 사용하는 디자인 패턴이다.
- 인스턴스가 필요할 때, 똑같은 인스턴스를 만들지 않고 기존의 인스턴스를 활용하는 것
- 생성자가 여러번 호출되도, 실제로 생성되는 객체는 하나이며 최초로 생성된 이후에 호출된 생성자는 이미 생성한 객체를 반환시키도록 만드는 것이다.

### 왜 사용할까?

- 먼저, 객체를 생성할 때마다 메모리 영역을 할당받아야 한다.
- 하지만 한번의 객체 생성을 통해 객체를 생성한다면 메모리 낭비를 방지할 수 있다.
- 또한, 싱글톤으로 구현한 인스턴스는 '전역'이므로, 다른 클래스의 인스턴스들이 데이터를 공유하는 것이 가능한 장점이 있다.

### 많이 사용하는 경우는 언제일까?

- 주로 공통된 객체를 여러 개 생성해서 사용해야하는 상황
- Ex. 데이터베이스에서 커넥션풀, 스레드풀, 캐시, 로그 기록 객체 등
- 또한, 인스턴스가 절대적으로 한 개만 존재하는 것을 보증하고 싶을 때 사용 함.

### 단점은 무엇일까?

- 객체 지향 설계 원칙 중에 개방-폐쇄 원칙이란 것이 존재한다.
- 만약 싱글톤 인스턴스가 혼자 너무 많은 일을 하거나, 많은 데이터를 공유시키면 다른 클래스 간의 결합도가 높아지게 되는데, 이때 개방-폐쇄 원칙이 위배된다.
- 결합도가 높아지게 되면, 유지보수가 힘들고 테스트도 원활하게 진행할 수 없는 문제점이 발생한다.
- 또한, 멀티 스레드 환경에서 동기화 처리를 하지 않았을 때, 인스턴스 2개가 생성되는 문제도 발생할 수 있다.
- 따라서, 반드시 싱글톤이 필요한 상황이 아니면 지양하는 것이 좋다고 한다.

### 코드 예시 

- UIColor와 관련된 로직을 처리하는 싱글톤 객체 코드 예시

```swift
import UIKit

class ColorManager {
    static let shared = ColorManager()
    
    private init() {}
    
    func getWhite() -> UIColor {
        return UIColor(named: "White")!
    }
    
    func getAntiFlashWhite() -> UIColor {
        return UIColor(named: "AntiFlashWhite")!
    }
    
    func getBegonia() -> UIColor {
        return UIColor(named: "Begonia")!
    }
    
    func getDarkLemonLime() -> UIColor {
        return UIColor(named: "DarkLemonLime")!
    }
    
    func getIguanaGreen() -> UIColor {
        return UIColor(named: "IguanaGreen")!
    }
    
    func getLightSilver() -> UIColor {
        return UIColor(named: "LightSilver")!
    }
    
    func getPear() -> UIColor {
        return UIColor(named: "Pear")!
    }
    
    func getPhilippineGray() -> UIColor {
        return UIColor(named: "PhilippineGray")!
    }
    
    func getPhilippineSilver() -> UIColor {
        return UIColor(named: "PhilippineSilver")!
    }
    
    func getPistachio() -> UIColor {
        return UIColor(named: "Pistachio")!
    }
    
    func getSpanishGray() -> UIColor {
        return UIColor(named: "SpanishGray")!
    }
    
    func getUFOGreen() -> UIColor {
        return UIColor(named: "UFOGreen")!
    }
    
    func getGainsboro() -> UIColor {
        return UIColor(named: "Gainsboro")!
    }
    
    func getPlatinum() -> UIColor {
        return UIColor(named: "Platinum")!
    }
    
    func getSonicSilver() -> UIColor {
        return UIColor(named: "SonicSilver")!
    }
    
    func getChineseSilver() -> UIColor {
        return UIColor(named: "ChineseSilver")!
    }
    
    func getSilverSand() -> UIColor {
        return UIColor(named: "SilverSand")!
    }
    
    func getManatee() -> UIColor {
        return UIColor(named: "Manatee")!
    }
    
    func getDavyGray() -> UIColor {
        return UIColor(named: "DavyGray")!
    }
    
    func getAmericanSilver() -> UIColor {
        return UIColor(named: "AmericanSilver")!
    }
    
    func getDarkCharcoal() -> UIColor {
        return UIColor(named: "DarkCharcoal")!
    }
    
    func getJetStream() -> UIColor {
        return UIColor(named: "JetStream")!
    }
    
    func getGreenSheen() -> UIColor {
        return UIColor(named: "GreenSheen")!
    }
    
    func getDeepMossGreen() -> UIColor {
        return UIColor(named: "DeepMossGreen")!
    }
    
    func getPhthaloGreen() -> UIColor {
        return UIColor(named: "PhthaloGreen")!
    }
    
    func getDarkJungleGreen() -> UIColor {
        return UIColor(named: "DarkJungleGreen")!
    }
    
    func getTomato() -> UIColor {
        return UIColor(named: "Tomato")!
    }
    
    func getGray() -> UIColor {
        return UIColor(named: "Gray")!
    }
    
    func getBrightGray() -> UIColor {
        return UIColor(named: "BrightGray")!
    }
    
    func getGhostWhite() -> UIColor {
        return UIColor(named: "GhostWhite")!
    }
}
```

