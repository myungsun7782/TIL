# 2023년 3월 10일(금)

---

### Today I Learned 

- [iOS-Swift] 속성(Property)

---

### 속성(Property)

### 1) 저장 속성(Stored Properties)

- 클래스 / 구조체 틀에서 찍어낸 **각 인스턴스가 가지는 고유의 데이터 저장 공간**
- 변수(var)나 상수(let)로 선언 가능 (만약 저장 속성을 let으로 선언하면 값을 바꿀 수 없음)
- **객체의 초기화시, 각 저장 속성은 반드시 값을 가져야 함**(기본 값 설정하거나 또는 생성자에서 설정, 또는 옵셔널 타입으로 선언하여 nil을 초기값으로 갖는 것 가능)
- (열거형의 경우 따로 메모리 공간이 필요한 저장 속성(데이터)은 선언할 수 없음)
- 코드 예시

```swift
struct Bird {
	var name = "eagle" // 저장 속성 --> 기본 값이 없으면, 생성자를 통해 값을 반드시 초기화 해야 함. 
	var weight = 0.0  // 저장 속성 
		
	func fly() {
		print("날아갑니다.") 
	}
}

var aBird = Bird(name: "참새", weight: 0.2)
aBird.name // 참새
aBird.weight = 0.3 
```

### 2) 지연 저장 속성(Lazy Stored Properties)

- 해당 속성이 반드시 처음부터 초기화가 필요하지 않은 경우(일반적으로 많은 메모리 공간을 차지하는 이미지 등)에 초기화를 지연시킴 (불필요한 성능저하나, 메모리 공간의 낭비를 줄일 수 있음)
- 값에 대한 접근이 있어야 초기화(메모리 공간 생성)
- 선언 시점에 기본 값을 저장해야 함
- lazy var로만 선언 가능(lazy let 안됨)
- 생성자에서 초기화하지 않기 때문에 반드시 기본 값이 필요
  - 기본 값은 표현식의 어떤 형태든 return 값만 일치하면 가능(함수 실행문, 계산식, 클로저 실행문 등)
- 지연 저장 속성을 사용하는 이유
  1. 메모리 공간의 낭비를 막을 수 있음
  2. 지연 저장 속성으로 선언되는 속성이 다른 저장 속성을 이용해야 할 때 (초기화 시점이 더늦으므로, 먼저 초기화되는 저장 속성을 사용 가능) (예시: b변수는 초기화할 때 a변수를 활용 가능)
     - 어떤 한 가지 속성이 다른 속성에 접근할 수가 없다. (그렇지만, 지연 저장 속성을 이용하는 경우 지연으로 저장된 속성은 먼저 초기화된 속성에 접근할 수 있게 됨

```swift
class AView {
	var a: Int

	// 1) 메모리를 많이 차지할 때 
	lazy var view = UIImageView() 

	// 2) 다른 속성을 이용해야 할 때 (다른 저장 속성에 의존해야만 할 때)
	lazy var b: Int = {
	    return a * 10 
	}() 

	init(num: Int) {
		self.a = num 
	}
}
```

- 코드 예시

```swift
struct Bird {
    var name: String 
    lazy var weight: Double = 0.2 // 지연 저장 속성 
		
    init(name: String) {
        self.name = name 
    }
		
	func fly() {
		print("새가 날아갑니다.")
	}
}

var aBird = Bird(name: "eagle") // weight 속성 초기화 안됨 
aBird.weight // <------ 해당 변수에 접근하는 이 시점에 초기화 됨 (메모리 공간이 생기고 숫자가 저장됨)

/**===========================================================
 - 저장 속성은 저장 속성인데, 지연(lazy)의 의미가 뭘까?

 - 지연 저장 속성은 "해당 저장 속성"의 초기화를 지연시키는 것임
 - 즉, 인스턴스가 초기화되는 시점에 해당 속성이 값을 갖고 초기화되는
   것이 아니라(메모리에 공간과 값을 갖는 것이 아니라),
 - 해당 속성(변수)에 접근하는 순간에 (해당 저장 속성만)개별적으로 초기화됨

 - 따라서, 상수로의 선언은 안되고 변수(var)로의 선언만 가능 (값이 변경되는 성격을 가지고 있기 때문에)
   ➡︎ lazy var만 가능(lazy let 불가능)

 - 즉, 위의 weight이라는 속성은 초기화 시점에 메모리 공간이 생기는 것이 아님
 - 예를 들어, 인스턴스가 생기고 난 후, aBird.weight 이렇게 접근하는
   순간 메모리 공간을 만들고 숫자를 저장 하게됨
=============================================================**/

/**============================================================
 - 생성자에서 초기화를 시키지 않기 때문에 "선언시점에 기본값을 저장"해야함

 - 지연(lazy) 저장 속성 ===> 구조체, 클래스 동일
 - 값을 넣거나, 표현식(함수 실행문)을 넣을수 있음(모든 형태의 표현식)
 - 함수호출 코드, 계산코드, 클로저 코드 등도 모두 가능
   ===> 저장하려는 속성과 "리턴형"만 일치하면 됨
 - 지연 저장 속성으로 선언된  "해당 속성"의 초기화 지연.
   ===> 메모리 공간이 없다가 처음 접근하는 순간에 (해당 속성만)개별적으로 초기화됨
================================================================*/
```

### 메서드의 메모리 동작

```swift
class Dog {
	var name: String 
	var weight: Double 

	init(name: String, weight: Double) {
		self.name = name
		self.weight = weight 
	}

	func sit() {
		print("강아지가 앉습니다.")
	}
		
	func layDown() {
		print("강아지가 눕습니다.")
	}
}

var bori = Dog(name: "보리", weight: 15.0) 

bori.sit() // 강아지가 앉습니다. 
bori.layDown() // 강이지가 눕습니다. 
```

- 클래스 정의 및 인스턴스를 생성하면 발생하는 일
  - Dog라는 클래스 틀은 데이터 영역에 저장 됨
  - bori 인스턴스의 실제 데이터들은 힙 영역에 저장 됨
  - bori 인스턴스의 실제 데이터들을 가리키는 메모리 주소는 스택 영역에 저장 됨
- bori.sit() 메서드를 호출하면 발생하는 일
  1. 스택에 저장되어 있는 bori 메모리 주소를 찾아간다.
  2. bori 메모리 주소가 가리키는 힙 영역에 있는 bori 데이터가 데이터 영역에 있는 Dog 클래스 틀 안에 있는 sit() 메서드 메모리 주소를 가리킨다.
  3. 데이터 영역에 있는 sit() 메서드의 메모리 주소를 통해 코드 영역으로 이동해 sit() 메서드의 명령어 묶음을 실행시킨다.
  4. sit() 메서드를 실행시키게 되면 스택 영역에 sit() 메서드의 프레임이 생성된다.
  5. sit() 메서드 실행이 끝나면 스택 프레임에서 사라진다.
- 참고
  - 구조체(Struct) 같은 경우에는 인스턴스 생성 시 스택 영역에 해당 인스턴스 값이 저장되는데, 인스턴스에서 메서드를 호출하게 되면 코드영역의 메서드 메모리 주소에 바로 접근하게 된다.

### 3) 계산 속성(Computed Properties) (연산 속성 / 프로퍼티) - getter(get 블록) / setter(set 블록)

- **속성의 형태를 가진 실질적 메서드 ⭐️** (일반적으로 다른 저장 속성에 의존한 결과로 나오는 그런 방식의 메서드를 속성처럼 만든 것)
- 메서드이기 때문에 인스턴스에 **메모리 공간이 할당되어 있지 않음**
- **var로만 선언 가능, 자료형까지 선언해야함**(형식 추론 방식 안됨) (메서드이기 때문에 파라미터, 리턴형이 필요한 개념)
- get 블록만 선언하면 **읽기 전용(read-only) 계산 속성이 됨** **(필수 구현)**
- set 블록은 **선택적으로 구현**할 수 있음(set만 구현하는 것은 불가능)
- set 블록에서 기본 파라미터 **newValue**가 제공됨 (직접 파라미터 이름 설정도 가능)
- 계산 속성은 실제 메모리 공간을 가지지 않고, 해당 속성에 접근했을 때 다른 속성에 접근해서 계산한 후, 그 계산 결과를 리턴하거나 세팅하는 메서드이다.
- 메서드가 아닌, 속성 방식으로 구현했을 때 장점
  - 관련이 있는 2가지 메서드(함수)를 한번에 구현할 수 있다.
  - 그리고 외부에서 보기에 속성 이름으로 설정가능하므로 보다 명확해 보인다.
  - 따라서, 계산 속성은 메서드를 개발자들이 보다 읽기 쉽고, 명확하게 쓸 수 있는 형태인 속성으로 변환해 놓은 것이다.
- 코드 예시

```swift
// 값이 저장되는 일반적인 속성(변수)을 저장 속성이라고 함 
// 그 동안 우리가 배운 속성은 정확한 의미에서 "저장 속성"이었음 --> 앞으로 저장 속성이 아닌 것을 배우게 됨 

/**====================================================
 - 먼저 "계산속성이 아닌 방식"으로 구현예시
=======================================================**/

// 비만도를 측정하는 체질량 지수(BMI)를 예시
// BMI = 65 / (1.65 * 1.65)    (몸무게를 키의 제곱으로 나누되, 키는 M미터 기준으로)

class Person {
	var name: String = "사람"
	var height: Double = 160.0
	var weight: Double = 60.0 

	func calculateBMI() -> Double {
		let bmi = weight / (height * height) * 10000
		return bmi 
	}
}

let aPerson = Person()
aPerson.height = 165 
aPerson.weight = 65 
aPerson.calculateBMI() // 23.875
// calculateBMI() 
// BMI를 계산하는 이 산식은 파라미터가 없고, 
// 내부에 가지고 있는 저장 속성 값을 이용해, 계산한 후 결과 값을 리턴한다. 

/**====================================================
 - 위의 사례를 계산속성(Computed Properties)으로 바꾸어서 구현하기 
=======================================================**/
class Person1 {
	var name: String = "사람"
	var height: Double = 160.0
	var weight: Double = 60.0 

	var bmi: Double {
		get { // getter --> 값을 얻는다는 의미 
		    let result = weight / (height * height) * 100000
			return result 
		}
		set { // setter --> 값을 세팅한다(넣는다)는 의미, newValue는 bmi에 새로 들어오는 값을 의미 
		    weight = newValue * height * height / 10000
		}
	}
//  만약에 쓰기 계산속성(set)을 메서드로 구현했다면
//  func setWeightWithBMI(bmi: Double) {
//       weight = bmi * height * height / 10000
//   }
}

let bPerson = Person1() 
bPerson.bmi // 계산 속성의 get 메서드 호출 --> 23.875
bPerson.bmi = 25 // 계산 속성의 set 메서드 호출
bPerson.weight // 68.0625

/**====================================================
 - 읽기만 가능한 계산 속성(read-only)은 get 블록을 생략 가능  
=======================================================**/
class Person2 {
	var name: String = "사람"
	var height: Double = 160.0
	var weight: Double = 60.0 

	var bmi: Double { // get블록만 있다면, 굳이 한번 더 감쌀 필요가 없다. ===> 편의를 위해 get을 생략가능
		let bmi = weight / (height * height) * 10000
		return bmi 
	}
}
```

- bPerson.bmi를 실행하면 발생하는 일 (주교재 p.393 참고)
  1. 힙 영역에 있는 bPerosn이 데이터 영역에 있는 Person1 클래스 틀 안에 있는 bmi.get() 메서드 메모리 주소를 가리킨다.
  2. 데이터 영역에 있는 bmi.get() 메서드의 메모리 주소를 통해 코드 영역으로 이동해 bmi.get() 메서드의 명령어 묶음을 실행시킨다.
  3. bmi.get() 메서드를 실행시키게 되면 스택 영역에 bmi.get() 메서드의 프레임이 생성된다.
  4. bmi.get() 메서드 프레임 안에는 bPerson의 메모리 주소가 들어있고, 이 메모리 주소를 통해 실제 인스턴스의 데이터를 저장하고 있는 힙 영역에서 필요한 데이터에 접근해서 get 연산을 수행한다.
- bPerson.bmi = 25를 실행하면 발생하는 일 (주교재 p.395 참고)
  1. 힙 영역에 있는 bPerosn이 데이터 영역에 있는 Person1 클래스 틀 안에 있는 bmi.set() 메서드 메모리 주소를 가리킨다.
  2. 데이터 영역에 있는 bmi.set() 메서드의 메모리 주소를 통해 코드 영역으로 이동해 bmi.set() 메서드의 명령어 묶음을 실행시킨다.
  3. bmi.set() 메서드를 실행시키게 되면 스택 영역에 bmi.set() 메서드의 프레임이 생성된다.
  4. bmi.set() 메서드 프레임 안에는 bPerson의 메모리 주소가 들어있고, 이 메모리 주소를 통해 실제 인스턴스의 데이터를 저장하고 있는 힙 영역에서 필요한 데이터에 접근해서 set 연산을 수행한다

### 4) 타입 속성(Type Properties)

- 인스턴스에 속한 속성이 아니고, 타입 자체에 속한 속성이기에 내/외부에서 Type.property로 접근해야함
- 저장 타입 속성을 주로 사용
- 타입 속성의 메모리 구조의 이해
  - 저장 타입 속성
    - 일반 저장 속성은 인스턴스를 생성할 때, 생성자에서 모든 속성을 초기화를 완료
    - 그리고, 해당 저장 속성은 각 인스턴스가 가진 고유한 값임
    - 하지만, 저장 타입(형식) 속성은 생성자가 따로 없기 때문에, 타입 자체(유형 그 자체)에 속한 속성이기 때문에 항상 기본 값이 필요 (생략할 수 없음)
    - 지연 속성의 성격을 가짐
      - 저장 타입 속성은 기본적으로 지연 속성(속성에 처음 접근하는 순간에 초기화 됨)이지만, lazy라고 선언할 필요는 없음(참고: 여러 스레드에서 동시에 엑세스하는 경우에도 한 번만 초기화되도록 보장됨 Thread-Safe)
- 종류
  1. 저장 타입 속성
     - 모든 인스턴스가 동일하게 가져야하는 보편적인 속성이거나, 모든 인스턴스가 공유해야하는 성격에 가까운 저장 속성을 저장 타입 속성으로 선언
     - static 키워드 사용. (상속 시)재정의 불가(메서드만 상속이 가능 - class 키워드 사용 불가)
     - let / var 선언 둘다 가능(저장 타입 속성)
     - 항상 기본값(초기값)필요(생성자에 의한 값 설정 과정이 없으므로)
     - 자체적으로 지연(lazy) 속성의 성격을 가지므로, 호출 시 메모리 할당**(내부적으로 Thread-Safe 처리)**
  2. 계산 타입 속성
     - (상속 시)재정의 가능(class 키워드 사용 시에만)
     - static 또는 class 키워드 사용(static 상속 시 재정의 불가 / class 상속 시 재정의 가능 의미임)
     - var 키워드만 사용 가능(계산 타입 속성)
     - 메서드이기 때문에 타입에 메모리 공간이 할당되어 있지 않음(계산 속성)
- 코드 예시

```swift
// static(고정적인/고정된)이라는 키워드를 추가한 저장 속성 
class Circle {
	// (저장) 타입 속성 (값이 항상 있어야 함) 
	static let pi: Double = 3.14 
	static var count: Int = 0 // 인스턴스의 갯수를 나타내는 속성

	// (계산) 타입 속성(read-only) 
	static var multiPi: Double {
		return pi * 2 
	} 
		
	// 저장 속성 
	var radius: Double // 반지름 

	// 계산 속성
	var diameter: Double { 
		get { 
			return radius * 2 
		}
		set {
			radius = newValue / 2 
		}
	}

	// 생성자 
	init(radius: Double) {
		self.radius = radius 
		Circle.count += 1 
	}
}

var aCircle = Circle(radius: 10)
aCircle.radius
aCircle.diameter
Circle.count // 인스턴스를 +1개 찍어냄

var bCircle = Circle(radius: 20)
bCircle.count // 인스턴스를 +1개 찍어냄 
```

### 5) 속성 감시자(Property Observer) - willSet / didSet

- **willSet** —> (값이 변할때) 새 값이 **저장되기 직전에 호출됨**

- **didSet** —> (값이 변할때) 새 값이 **저장된 직후에 호출됨**

- **저장 속성 자체는 var로만 선언 가능**(let은 관찰필요 없음, 지연저장 속성은 관찰 안됨)

- **자료형을 선언하는 것은 일반 변수와 동일**(기본값을 넣으면 형식 추론 방식 가능함)

- 저장 속성의 변화시점을 관찰하는실질적 메서드

  (타입/인스턴스 둘다 가능은 함)

  - 상속한 계산 속성을 재정의해, 관찰 가능하지만 주로 저장 속성에서 사용

- **willSet** 또는 **didSet** 중에서 한가지만 구현하면 됨(일반적으로 didSet으로 구현)

- 변수가 변하면, (무엇인가) 업데이트 하려는 패턴 구현할 때 사용

  - 예시) 상태 메시지, 프로필 사진 서버에서 변화 —> (바로) 화면 업데이트

- 속성 감시자 추가 가능한 경우

  (인스턴스 속성)

  1. **저장 속성**(상속한 저장 속성은 재정의 불가, 감시자 추가는 가능)

  2. 상속한 계산 속성

     을 재정의해 속성관찰자 추가 가능(단순 메서드 추가일뿐)

     - 본래의 계산 속성에는 setter에서 값의 변경을 관찰 가능하므로 추가 불가

- 코드 예시

```swift
class Profile {
	// 일반 저장 속성 
	var name: String = "이름"
		
	// 저장 속성 + 저장 속성이 변하는 시점을 관찰하는 메서드 
	var statusMessage: String = "기본 상태 메시지" {
		willSet { // willSet(파라미터 이름) 형태로도 사용 가능 
			print("메시지가 \(statusMessage)에서 \(newValue)로 변경될 예정입니다.")
			print("상태 메시지 업데이트 준비")
		}
		didSet { // didSet(파라미터 이름) 형태로도 사용 가능 
			print("메시지가 \(oldValue)에서 \(statusMessage)로 이미 변경되었습니다.")
			print("상태 메시지 업데이트 완료")
		}
	}
}

let aProfile = Profile()
aProfile.name // 이름 
aProfile.name = "myungsun" 

aProfile.statusMessage // 기본 상태 메시지  
aProfile.statusMessage = "iOS"
// 호출 순서
// willSet -->  name[   "iOS"   ] --> didSet 

// 결과
// 메시지가 기본 상태 메시지에서 iOS로 변경될 예정입니다.
// 상태 메시지 업데이트 준비 
// 메시지가 기본 상태 메시지에서 iOS로 이미 변경되었습니다. 
// 상태 메시지 업데이트 완료 
```