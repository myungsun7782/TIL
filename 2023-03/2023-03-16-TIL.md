# 2023년 3월 16일(목)

---

### Today I Learned 

- [iOS-Swift] 클래스의 상속과 초기화

---

## 재정의 규칙⭐️

> 대원칙: 
>
> - **저장 속성 재정의 불가**
> - 메서드는 재정의 가능(다만, 기능 확장만 가능)

### 1) 저장 속성 

- 원칙 => 재정의 불가 ==> 메모리 구조에서 상위 구현을 참조하기 때문에 재정의(변형) 불가능 

- 예외

  - 메서드 형태로 부수적 추가능 가능(메모리 구조를 건드리지 않는 형태로는 가능)

    1. 읽기 / 쓰기 계산속성 형태로 재정의 가능(메서드 추가 형태로 구현)

    2. 속성 감시자 형태로 재정의 가능(실질적 단순 메서드 추가)

### 2) 계산 속성(실질적 메서드)

- 계산 속성의 재정의는 실질적 메서드 대체 
- 확장 방식의 재정의 가능
  1. 읽기 => 읽기 / 쓰기 가능(기능 확장 가능)
  2. 읽기 / 쓰기 => 읽기는 불가능(기능 축소 불가능)
- 속성 감시자를 추가하는 재정의 가능(실질적 단순 메서드 추가)

### 3) 생성자

- 생성자는 기본적으로 상속되지 않고 재정의 원칙 
- 원칙:
  1) 상위 지정생성자와 고려해서 구현 
  2) 현재 단계의 저장 속성을 고려해서 구현 
- 예외:
  - 생성자의 자동 상속 - 지정 생성자 / 편의 생성자 자동 상속의 경우 있음 

### 4) 메서드

- 일반적으로 상위 구현의 메서드를 대체 및 변형할 수 있으므로, 자유롭게 재정의(상위 구현을 호출하는 경우도 많으니 주의) 

<br/>

## 초기화(Initialization)

### 초기화와 생성자(Initializer)

- 초기화 메서드(생성자)
  - 함수의 구현이 특별한 키워드인 **init으로 명명됨**
  - 인스턴스를 생성하는 과정: 저장 속성에 대한 초기값을 설정하여 사용 가능한 상태가 되는 것 
  - 생성자 메서드의 실행 목적은, **모든 저장 속성 초기화**를 통한 인스턴스 생성
    - 즉, 생성자 실행의 종료 시점에는 모든 저장 속성에 값이 저장되어 있어야 함 
  - 설계도(클래스, 구조체, 열거형)을 실제로 사용하기 위해 인스턴스를 찍어내는 과정 
  - 생성자 실행시, 메모리 내에 실제 인스턴스를 생성하는 복잡한 코드가 (자동)구현된다고 생각하면 됨 
- 오버로딩 지원 
  - 다양한 파라미터 조합으로 **생성자 여러개 구현 가능** (여러가지 방식으로 인스턴스를 생성하는 방법을 제공하는 것)
  - 생성자를 직접 구현하지 않으면 ⭐️(사용자 정의 (직접) 구현이 일단 원칙) (개발자의 의도가 우선)
    1. **모든 저장 속성에 기본 값(또는 옵셔널 타입) 전제**
       - 클래스: 기본 생성자 init() 제공(초기화 방법 필요)
       - 구조체: 기본 생성자 init() 제공(초기화 방법 필요) + 맴버와이즈 이니셜라이저도 기본 제공(맴버를 위한 기본 제공 / 새로운 값으로 설정 가능)
    2. **(일부) 저장 속성에 기본값 (또는 옵셔널 타입) 전제**
       - 클래스: 원칙적으로 일부 값만 가지고, 생성자 구현하지 않는 방법이 존재하지 않음 
       - 구조체: 맴버와이즈 이니셜라이저 기본 제공(편의를 위한 기본 제공 => 일부 / 전체 저장 속성 새로운 값으로 설정 가능)
         - 맴버와이즈 이니셜라이저: 직접 구현하지 않아도, 자동으로 제공해주는 저장 속성 설정가능한 생성자 
- 생성자(Initializer) 구현의 기본 코드 예시 

```swift
// 클래스, 구조체, (열거형) 동일 
// 아래 방식 처럼 생성자를 구현하는 것이 올바른 방법은 아님 --> 코드 중복 발생! 
class Color {
	let red: Double
	let green: Double
	let blue: Double

	// 생성자도 오버로딩(Overloading)을 지원 (파라미터의 수, 아규먼트 레이블, 자료형으로 구분)
	init() { // 기본 생성자 --> 기본 값을 설정하면 자동으로 제공됨
		red = 0.0
		green = 0.0
		blue = 0.0
	}

	init(white: Double) {
		red = white
		green = white 
		blue = white 
	}

	init(red: Double. green: Double, blue: Double) {
		self.red = red
		self.green = green 
		self.blue = blue
	}
}

// 인스턴스 생성 + 초기화 메서드(생성자) 호출
var color = Color()
color = Color(white: 10.0)
color = Color(red: 0.0, green: 0.0, blue: 0.0)

/**===================================================
 - 초기화의 방법(저장속성이 초기값 가져야 함)
 - 1) 저장 속성의 선언과 동시에 값을 저장
 - 2) 저장 속성을 옵셔널로 선언 (초기값이 없어도 nil로 초기화됨)
 - 3) 생성자에서 값을 초기화

 - 반드시 생성자를 정의해야만 하는 것은 아님 ⭐️
 
 - 1-2번 방법으로 이니셜라이저를 구현하지 않아도,
 - 컴파일러는 기본 생성자(Default Initializer)를 자동으로 생성함 ==> init()
 - ==> 이니셜라이저 구현하면, 기본 생성자를 자동으로 생성하지 않음
======================================================**/ 
```

- 맴버와이즈 이니셜라이저(Memberwise Initializer) 코드 예시

```swift
struct Color {
	var red, green, blue: Double 

// 구조체는 init 메서드를 생략해도 컴파일러가 알아서 자동으로 넣어준다. --> 맴버와이즈 이니셜라이저
//  init(red: Double, green: Double, blue: Double) {
//      self.red = red
//      self.green = green
//      self.blue = blue
//  }
}
var color = Color(red: 1.0, green: 1.0, blue: 1.0)

// --> 구조체에서만 선언된 저장 속성의 이름을 파라미터로 제공하기 때문에
// 멤버에 관한 생성자를 제공한다는 뜻에서 멤버와이즈 이니셜라이저라고 부름
// (Memberwise 뜻: 멤버에 관하여) ( ~ wise:  ~ 에 관하여)

/**============================================================
 - 생성자 기본 원칙
 - 컴파일러는 기본 생성자(Default Initializer)를 자동으로 생성함 ==> init()
 - ==> 이니셜라이저 구현하면, 기본 생성자를 자동으로 생성하지 않음

 - 구조체는 저장 속성들이 기본값을 가지고 있더라도,
 - 추가적으로 Memberwise 멤버와이즈(멤버에 관한) 이니셜라이저를 자동으로 제공함

 - 개발자가 직접적으로 생성자를 구현하면, 멤버와이즈 이니셜라이저가 자동으로 제공되지 않음 ⭐️
   (멤버와이즈 이니셜라이저는 편의적 기능일뿐)
 ==============================================================**/

/**==================================================
 - 왜 멤버와이즈 이니셜라이저를 제공할까?
 
 - 굳이 이유를 찾자면, 클래스보다 더 편하게 쓰기 위함일 것으로 추측
 - 클래스의 경우에는, 생성자가 상속하고 관련이 있기 때문에 복잡
=====================================================**/
```

