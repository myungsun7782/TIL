# 2024-12-10-TIL

# 프로세스와 스레드

- 메모리에는 컴퓨터가 실행되는 순간부터 다양한 프로세스들이 적재되어 실행됨.
- 프로세스의 유형으로는 사용자가 보는 공간에서 사용자와 상호작용하며 실행되는 **포그라운드 프로세스(foreground process)**도 있고, 사용자가 보지 못하는 곳에서 실행되는 **백그라운드 프로세스(background process)**도 있음
- 백그라운드 프로세스 중에서도 사용자와 별다른 상호작용 없이 주어진 작업만 수행하는 특별한 백그라운드 프로세스인 **데몬(daemon)**도 있음. 윈도우 운영체제에서는 데몬을 서비스(service)라고 부름
- 하지만, 프로세스의 유형을 막론하고 하나의 프로세스를 구성하는 메모리 내의 정보는 크게 다르지 않음.
- 다음과 같이 커널 영역에는 프로세스 제어 블록(PCB)이라는 정보가 저장되고, 사용자 영역에는 실행 중인 프로세스가 코드 영역, 데이터 영역, 힙 역역, 스택 영역으로 나뉘어 저장됨.
  - 코드 영역
    - 실행 가능한 명령어가 저장되는 공간으로, 텍스트 영역(text segment)이라고도 부름
    - CPU가 읽고 실행할 명령어가 담겨 있기 때문에 쓰기가 금지되어 있는 읽기 전용(read-only) 공간임.
  - 데이터 영역
    - 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
    - 데이터 영역에 저장되는 데이터는 **정적 변수**나 **전역 변수**가 대표적
    - 코드 영역과 데이터 영역은 프로그램 실행 도중 크기가 변하지 않기 때문에 **정적 할당 영역**이라고 부름
    - 반면에, 크기가 변할 수 있는 힙 영역과 스택 영역은 **동적 할당 영역**이라고 부름
  - 힙 영역
    - 프로그램을 만드는 사용자(개발자)가 직접 할당 가능한 저장 공간
    - 프로그램 실행 도중 비교적 자유롭게 할당하여 사용 가능한 메모리 공간이라 볼 수 있음
    - 다만, 힙 영역에 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야 함.
    - 메모리 공간을 반환하지 않으면 할당한 공간이 계속 메모리 내에 남아 메모리를 낭비하는 **메모리 누수(memory leak)**문제를 초래할 수 있음.
    - 때로는 이러한 문제를 해결하기 위해 프로그래밍 언어에서 자체적으로 사용되지 않은 힙 메모리를 해제하는 **가비지 컬렉션(garbage collection)** 기능을 제공하기도 함.
  - 스택 영역
    - 데이터 영역에 담기는 값과는 달리 일시적으로 사용할 값들이 저장되는 공간.
    - 함수의 실행이 끝나면 사라지는 **매개변수, 지역 변수, 함수 복귀 주소** 등이 스택 영역에 저장되는 대표적인 데이터들임.
    - 스택 트레이스 형태의 함수 호출 정보가 저장될 수 있다는 점을 기억해야 함.
    - 스택 트레이스(stack trace)란 특정 시점에 스택 영역에 저장된 함수 호출 정보를 말함.
    - 스택 트레이스로는 문제의 발생 지점을 추적할 수 있어, 디버깅에 매우 유용하게 사용됨

<img width="491" alt="image" src="https://github.com/user-attachments/assets/0dfb4d95-ac47-45be-8d08-5e1a09feab09">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

## PCB와 문맥 교환 

- 운영체제가 메모리에 적재된 다수의 프로세스를 관리하려면 프로세스를 식별할 수 있는 커널 영역 내의 정보가 필요.
- 이 정보가 바로 **프로세스 제어 블록(이하 PCB)(Process Control Block)**
- PCB는 프로세스와 관련한 다양한 정보를 내포하는 구조체의 일종으로, 새로운 프로세스가 메모리에 적재(프로세스 생성)됐을 때 커널 영역에 만들어지고, 프로세스의 실행이 끝나면 폐기됨.
- PCB에 담기는 정보는 운영체제마다 차이가 있지만, 대표적으로 프로세스 식별 번호인 **프로세스 ID(이하 PID)**와 프로세스가 **실행 과정에서 사용한 레지스터 값**, 프로세스가 현재 어떤 상태인지를 나타내는 **프로세스 상태**, 프로세스가 언제, 어떤 순서로 CPU를 할당받을지 나타내는 **CPU 스케줄링(우선순위)정보**, 프로세스의 메모리상 적재 위치를 알 수 있는 **메모리 관련 정보**, 프로세스가 사용한 **파일 및 입출력장치 관련 정보**가 명시됨
- 이때 여러 PCB들은 커널 내에 **프로세스 테이블(process table)**의 형태로 관리되는 경우가 많음.
- 프로세스 테이블은 실행 중인 PCB의 모음을 의미함.
- 새롭게 실행되는 프로세스가 있다면 해당 프로세스의 PCB를 프로세스 테이블에 추가하고, 필요한 자원을 할당함. 반대로, 종료되는 프로세스가 있다면 사용 중이던 자원을 해제하고 PCB도 프로세스 테이블에서 삭제됨
  - 프로세스가 비정상 종료되어 사용한 자원이 회수되었음에도 프로세스 테이블에 종료된 프로세스의 PCB가 남아 있는 경우가 있음. 이러한 비정상 종료 상태를 **좀비 프로세스(zombie process)**라고 함.

<img width="450" alt="image" src="https://github.com/user-attachments/assets/95dfb411-e349-4000-a0c8-77ad9cf1fc0f">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

- 일반적으로 메모리에 적재된 프로세스들은 한정된 시간 동안 번갈아 가며 실행됨.
- 이때, **프로세스가 실행된다**는 말은 **운영체제에 의해 CPU의 자원을 할당받았다는 말과 같음.**
- CPU가 프로세스를 구성하는 명령어와 데이터를 인출하여 실행하고, 운영체제가 CPU 자원을 할당하기 때문. 즉, '다양한 프로세스들이 한정된 시간 동안 번갈아 가며 실행된다'는 말은 '다양한 프로세스들이 한정된 시간 동안 운영체제로부터 CPU의 자원을 번갈아 가며 할당받아서 이용한다'는 말과 같음
- 프로세스의 CPU 사용 시간은 타이머 인터럽트에 의해 제한됨.
  - 타이머 인터럽트 => 시간이 끝났음을 알리는 인터럽트로, 타임아웃 인터럽트라고도 부름
- 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU를 이용하고, 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다림. 
- 예를 들어, 다음과 같이 프로세스 A가 운영체제로부터 CPU를 할당받아 실행되다가, 타이머 인터럽트가 발생하여 프로세스 B로 CPU 사용을 양보한다고 가정
  - 이 때 프로세스 A는 프로그램 카운터를 비롯한 각종 레지스터 값과 메모리 정보, 실행을 위해 열었던 파일, 사용한 입출력장치 등 지금까지의 중간 정보를 **백업**해야 함. 그래야 다음에 다시 프로세스 A를 실행할 차례가 되었을 때 이전까지 실행했던 내용은 이어서 재개할 수 있음.
  - 여기서 백업 대상이 되는 중간 정보, 즉 프로세스의 수행을 재개하기 위해 기억해야 할 정보를 **문맥(context)**이라고 함.
  - 프로세스의 문맥은 해당 프로세스의 PCB에 명시됨.
  - 프로세스가 CPU를 사용할 수 있는 시간이 다 되거나 인터럽트가 발생하면 **운영체제는 해당 프로세스의 PCB에 문맥을 백업**함. 그리고 뒤이어 **실행할 프로세스의 문맥을 복구**함.
  - 이처럼 기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 새로운 프로세스를 실행하는 것을 **문맥 교환(context switching)**이라고 함.
    - 문맥 교환은 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리
- 언뜻 보면 프로세스를 자주 번갈아 가며 수행할수록 많은 프로세스를 동시에 실행할 수 있어 좋을 것이라고 생각할 수도 있지만, 사실은 그렇지 않음. 프로세스 간에 너무 잦은 문맥교환이 발생하면 캐시 미스가 발생할 가능성이 높아져 메모리로부터 실행할 프로세스의 내용은 가져오는 작업이 빈번해지고, 이는 큰 오버헤드로 이어질 수 있음

<img width="510" alt="image" src="https://github.com/user-attachments/assets/4249d846-8c84-4073-b001-8f359f9d2f3b">

<img width="597" alt="image" src="https://github.com/user-attachments/assets/33575099-6368-4a8a-a37d-5cf3bdc648c6">

<img width="610" alt="image" src="https://github.com/user-attachments/assets/91b46975-ffde-40be-9ebd-d4670c826557">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

## 프로세스의 상태

- 하나의 프로세스는 여러 상태를 거치며 실행됨.
- 운영체제는 PCB를 통해 프로세스의 상태를 인식하고 관리함.
- 운영체제마다 프로세스의 상태를 표현하는 방식은 조금씩 차이가 있지만, 대표적인 상태로는 생성, 준비, 실행, 대기, 종료 등이 있음

<img width="615" alt="image" src="https://github.com/user-attachments/assets/9e9f73ab-8965-4e69-9033-3601cda30e41">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

## 블로킹 입출력과 논블로킹 입출력

- 블로킹 입출력
  - 프로세스가 실행 도중 입출력 작업을 수행해야 하는 상황을 생각해보자. 일반적으로 프로세스는 이 상황에서 대기 상태로 접어들고, 입출력 작업이 완료되면 준비 상태가 되어 실행을 재개함.
- 논블로킹 입출력
  - 입출력 작업을 수행할 모든 프로세스가 반드시 대기 상태에 접어들 필요는 없음.
  - 때로는 입출력장치에게 입출력 작업을 맡긴 뒤, 곧바로 이어질 명령어를 실행할 수도 있음.

<img width="321" alt="image" src="https://github.com/user-attachments/assets/53258a60-6fd8-4397-a34b-df21b5eac36b">

(그림출처: 이것이 취업을 위한 컴퓨터 과학이다.)

