# 2023년 4월 20일(목)

---

### Today I Learned 

- [iOS-Swift] 함수(Function)

---

### 함수 실행의 메모리 구조 ⭐️

- 함수가 실행 되면 스택 프레임에 쌓인다.
  - Stack —> 차곡 차곡 아래에서부터 쌓이고, 제거 할때는 위에서부터 제거할 수 있는 구조
  - 함수 실행만이 스택 프레임을 만들 수 있고, 조건문 이나 반복문은 스택 프레임을 만들지 않는다.
- 예제 코드 (부교재 p.129 ~ p.149 참고)

```swift
func addTwoNumbers(a: Int, b: Int) -> Int {
	var c = a + b 
	return c 
}

var num1 = 5
var num2 = 3 
var num3 = addTwoNumbers(a: num1, b: num2) 
```

1. main() 함수가 실행되면서 스택 프레임에 쌓인다.
2. num1 메모리 공간에 5 값을 저장한다.
3. num2 메모리 공간에 3 값을 저장한다.
4. num3 메모리 공간을 만든다. (값을 저장하지는 않음)
5. addTwoNumbers(a: b:) 라는 함수를 실행시키면서, stack 영역 안에서 main() 프레임 위에 addTwoNumbers() 함수 스택 프레임을 쌓는다.
6. CPU는 addTwoNumbers(a: b:) 함수를 찾아가서 제일 먼저 명령어 복귀 주소(해당 함수가 종료되면 어디로 돌아갈지에 대한 주소)를 저장한다.
7. 함수 값을 저장할 공간을 만든다. (addTwoNumbers(a: b:) 함수는 리턴 값이 있는 경우이므로 해당 공간을 만드는 것이고, 리턴 값이 없는 경우에는 함수 값을 저장할 공간을 만들지 않음)
8. 파라미터 상수 a에 대한 메모리 공간에 5를 저장한다.
9. 파라미터 상수 b에 대한 메모리 공간에 3을 저장한다.
10. CPU가 a + b 연산을 수행한다.
11. c 메모리 공간에 a + b 연산 결과 값을 저장한다.
12. c에 저장된 값을 7번 과정에서 만든 함수 값 저장 공간에 넣는다.
13. 함수 값 저장 공간에 있는 값을 main() 스택 프레임 안에 있는 num3에 반환하면서 addTwoNumbers(a: b:) 스택 프레임은 사라진다.
14. 프로그램이 종료 되면서 main() 스택 프레임도 사라진다.

<br/>

### 입출력 파라미터

**inout키워드를 통한 입출력 파라미터의 구현**

```swift
// 함수를 통해, 변수를 직접 수정하고 싶은 경우는 어떻게 해야할까?
// 함수 내의 파라미터는 기본적으로 값 타입(복사돼서 전달)이고 임시 상수이기 때문에 변경 불가 원칙 
var num1 = 1 // 전역 변수 
var num2 = 7 // 전역 변수 

func swap(a: Int, b: Int) {
	var temp = a 
	a = b 
	b = c 
}

swap(a: num1, b: num2) 
print(num1, num2) // 1 7 ---> swap(a:b:) 함수를 호출한 뒤에도 num1과 num2는 값이 바뀌지 않음 

// 함수 내에서 변수를 직접 수정하도록 돕는 inout 키워드 (참조로 전달) 
// inout 키워드(함수 선언시), & 사용(함수 실행시)

func swapNumber(a: inout Int, b: inout Int) {
	var temp = a 
	a = b
	b = temp
}

// 함수 실행 시에는 앰퍼샌드(&)를 꼭 붙여야 함
swapNumbers(a: &num1, b: &num2)
print(num1, num2) // 7 1 ---> num1과 num2 값이 바뀜 

// 입출력 파라미터는 내부적으로 copy-in, copy-out 메모리 모델를 사용하지만, 실제 원본이 전달된다고 쉽게 생각하면 됨
// *copy-in, copy-out - 값을 복사해서 함수 바디 내부로 전달하고,
// 함수가 종료될때, 아규먼트로 전달한 변수에 복사됨(함수 바디 내부에서 외부로 복사되어 전달)
```

- inout 파라미터 사용 시 주의 점
  1. 상수(let)나, 리터럴 전달하는 것 불가능
  2. 파라미터의 기본 값 선언을 허용하지 않음
  3. 가변 파라미터(여러 개의 파라미터)로 선언 하는 것 불가능

### 가드문(guard statement)

**불만족하는 조건을 사전에 걸러내는 조건문**

if문의 단점:

- 여러 개의 조건이 있을 때 코드의 가독성이 문제 됨 —> guard문으로 단점 극복

**guard문:**

1. else문을 먼저 배치 - 먼저 조건을 판별하여 조기 종료(early exit)
2. 조건을 만족하는 경우 코드가 다음 줄로 넘어가서 계속 실행
3. 가드 문에서 선언된 변수를 아래 문장에서 사용 가능 (동일한 스코프로 취급) (guard let 바인딩 관련)

- 사용 이유
  1. 가독성을 높임 / if문의 불편함을 해소 (조건을 만족해야 다음 문장, 조건 불만족 걸러내기)
  2. 여러 개의 옵셔널 타입을 안전하게 벗기기 가능
     - code의 영역이 변경되지 않음 (범위(Scope)에 대한 원칙에서 벗어나서 자유로운 코드 작성)
     - guard 문에서 선언된 변수를 아래 문장에서 사용 가능 (동일한 범위(Scope) 취급)
- 사용 예시

```swift
// 반드시 코드를 종료해야 하는 조기 종료의 조건이 필요하므로, 로컬 스코프(함수/반복문) 내에서만 사용 가능
func check(word: String) -> Bool {
	guard words.count >= 5 else { // words의 글자 수가 5 미만이면 else 문을 실행 
			print("5글자 이하입니다.")
			return false  // 종료 조건 - 함수 내에서는 return / throw 사용 
	}
	print("\(words.count)글자입니다.")
	return true 
}

check(words: "안녕하세요") // 5글자입니다. 
```