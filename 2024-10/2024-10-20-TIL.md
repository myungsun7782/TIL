# 2024-10-20-TIL

안녕하세요.

10월 4주차 TIL 정리한 것들에 대해 복습하는 시간을 가져보겠습니다.

## 제네릭(Generic)

> 타입에 관계 없이, 하나의 정의(구현)로 모든 타입(자료형)을 처리할 수 있는 문법

### 제네릭 문법의 필요성

```swift
var num1 = 10
var num2 = 20

// 두 숫자를 스왑(서로 교환)하는 함수의 정의
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let tempA = a
    a = b
    b = tempA
}

// 위에서 정의한 함수의 실행
swapTwoInts(&num1, &num2)

print(num1)
print(num2)

// 만약, Double을 교환하고 싶다면?, String을 교환하고 싶다면?
// Double을 스왑하는 함수의 정의
func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
    let tempA = a
    a = b
    b = tempA
}

// (정수가 아닌) 문자열을 스왑하는 함수의 정의
func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let tempA = a
    a = b
    b = tempA
}

// 위의 함수들(swapTwoInts, swapTwoDoubles, swapTwoStrings)을 제네릭 함수로 정의
// 한번의 구현으로 모든 타입을 커버가능한 문법: 제네릭
func swapTwo<T>(_ a: inout T, _ b: inout T) {
    let tempA = a
    a = b
    b = tempA
}
```

- 제네릭이 없다면, 함수(클래스, 구조체, 열거형 등) 타입마다 모든 경우를 다 정의해야 하기 때문에 개발자의 할일이 늘어납니다. 즉, 유지보수, 재사용성 관점에서 어렵습니다.
- 타입(형식)에 관계없이 한번의 구현으로 모든 타입을 처리하여 유연한(유지보수 쉽고, 재사용성 높은) 함수 / 구조체 / 클래스 / 열거형 등을 일반화 가능한 코드로 작성할 수 있습니다.
- 타입 파라미터는 실제 자료형으로 대체되는 플레이스 홀더(어떤 기호같은 것)입니다. (새로운 형식이 생성되는 것은 아닙니다.)
  - 코드가 실행될 때 문맥에 따라서 실제 형식으로 대체되는 "플레이스 홀더"일 뿐입니다.

<br/>

### 제네릭 함수, 의 작성

#### 1. 타입 파라미터의 지정

- 함수의 이름 마지막 < >를 쓰고, 안에 타입 파라미터를 작성합니다.
- 타입 파라미터는 대문자로 시작하면 상관없습니다.(예를 들어, <A>, <U>, <Element>, <T, U>) 
  - 관습적으로 Type(타입)의 의미인 대문자 T를 사용하지만, 다른 문자를 사용해도 됩니다.
- 함수 내부에서 파라미터 형식이나 리턴형, 내부 변수타입으로 사용됩니다.
- 실제 타입 대신에 사용하는 '플레이스 홀더' 역할을 합니다.(어떤 타입이 입력되어야 한다는 것을 제시합니다.)

#### 2. 타입 파라미터의 사용

- 본래 타입의 사용하는 위치(파라미터, 바디, 리턴형)에서 타입이 필요한 곳에 타입 파라미터를 사용합니다. => 실제 함수 호출 시에 실제 타입으로 치환합니다.

```swift
// 한번의 구현으로 모든 타입을 커버가능한 문법: 제네릭
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let tempA = a
    a = b
    b = tempA
}

var string1 = "hello"
var string2 = "world"

// 제네릭으로 정의한 함수 사용해보기
swapTwoValues(&string1, &string2)     // 같은 타입이라면, 어떠한 값도 전달 가능 해짐
print(string1) // world
print(string2) // hello

// 배열을 출력하는 예제
func printArray<T>(array: [T]) {
    for element in array {
        print(element)
    }
}
```

<br/>

### 제네릭 타입(클래스, 구조체, 열거형)의 작성

#### 1. 타입 파라미터의 지정

- 타입 이름 마지막 < >를 쓰고, 안에 타입 파라미터를 작성합니다.
- 타입 파라미터는 대문자로 시작하면 상관없습니다.(예를 들어, <A>, <U>, <Element>, <T, U>) 
  - 관습적으로 Type(타입)의 의미인 대문자 T를 사용하지만, 다른 문자를 사용해도 됩니다.
- 함수 내부에서 파라미터 형식이나 리턴형, 내부 변수타입으로 사용됩니다.
- 실제 타입 대신에 사용하는 '플레이스 홀더' 역할을 합니다.(어떤 타입이 입력되어야 한다는 것을 제시합니다.)

#### 2. 타입 파라미터의 사용

- 본래 타입의 사용하는 위치(프로퍼티, 메서드)에서 타입이 필요한 곳에 타입 파라미터를 사용합니다. => 실제 함수 호출 시에 실제 타입으로 치환합니다.

#### 3. 제네릭 타입 확장 시

- 타입 파라미터 명시없이 확장합니다.
- 본체의 제네릭에서 정의한 타입 파라미터를 사용 가능합니다.

```swift
// 구조체로 제네릭 정의
struct GenericMember<T> {
    var members: [T] = []
}

var member1 = GenericMember(members: ["Jobs", "Cook", "Musk"])
var member2 = GenericMember(members: [1, 2, 3])

// 클래스로 제네릭 정의
class GridPoint<A> {
    var x: A
    var y: A
    
    init(x: A, y: A){
        self.x = x
        self.y = y
    }
}

let aPoint = GridPoint(x: 10, y: 20)
let bPoint = GridPoint(x: 10.4, y: 20.5)

// 열거형에서 연관값을 가질때 제네릭으로 정의가능
// (어짜피 케이스는 자체가 선택항목 중에 하나일뿐(특별타입)이고, 그것을 타입으로 정의할 일은 없음)
enum Pet<T> {
    case dog
    case cat
    case etc(T)
}

let animal = Pet.etc("고슴도치")
```

```swift
// 정의
struct Coordinates<T> {
    var x: T
    var y: T
}

// 제네릭을 Extension(확장)에도 적용할 수 있다. (확장 대상을 제한하는 것도 가능은 함)
// 본체의 제네릭에서 정의한 타입 파라미터 사용 가능
extension Coordinates {     // Coordinates<T> (X)
    // 튜플로 리턴하는 메서드
    func getPlace() -> (T, T) {
        return (x, y)
    }
}

let place = Coordinates(x: 5, y: 5)
print(place.getPlace()) // (5, 5)

// where절 추가도 가능
// Int타입에만 적용되는 확장과 getIntArray() 메서드
extension Coordinates where T == Int {     // Coordinates<T> (X)
    // 튜플로 리턴하는 메서드
    func getIntArray() -> [T] {
        return [x, y]
    }
}

let place2 = Coordinates(x: 3, y: 5)
place2.getIntArray() // [3, 5]
```

<br/>

### 제네릭의 타입 제약

- 제네릭에서 사용하는 타입에 대한 제약을 줄 수 있는 2가지 방법이 있습니다.
  1. 프로토콜 제약 <T: Equatable>
     - 특정 프로토콜을 따르는 타입만 가능하도록 제약을 줄 수 있습니다.
  2. 클래스 타입 제약 <T: SomeClass>
     - 특정 클래스와 상속관계 내에 속하는 클래스 타입만 가능하도록 제약을 줄 수 있습니다.

```swift
// Equatable 프로토콜을 채택한 타입만 해당 함수에서 사용 가능 하다는 제약
func findIndex<T: Equatable>(item: T, array:[T]) -> Int? {     // <T: Equatable>
    for (index, value) in array.enumerated() {
        if item == value {
            return index
        }
    }
    return nil
}

let aNumber = 5
let someArray = [3, 4, 5, 6, 7]

if let index = findIndex(item: aNumber, array: someArray) {
    print("밸류값과 같은 배열의 인덱스: \(index)")
}

// 클래스 제약의 예시
class Person {}
class Student: Person {}

let person = Person()
let student = Student()

// 특정 클래스와 상속관계에 내에 있는 클래스만 타입으로 사용할 수 있다는 제약  (구조체, 열거형은 사용 못함)
// (해당 타입을 상속한 클래스는 가능)
func personClassOnly<T: Person>(array: [T]) {
    // 함수의 내용 정의
}

personClassOnly(array: [person, person])
personClassOnly(array: [student, student])

// 반대로 구체/특정화(specialization) 함수 구현도 가능

/**=================================================================================
 - 항상 제네릭을 적용시킨 함수를 실행하게만 하면, 또다른 불편함이 생기지 않을까?
 - (제네릭 함수가 존재하더라도) 동일한 함수이름에 구체적인 타입을 명시하면, 해당 구체적인 타입의 함수가 실행됨
 ===================================================================================**/

// 문자열의 경우, 대소문자를 무시하고 비교하고 싶어서 아래와 같이 구현 가능 ⭐️
// 위의 findIndex<T: Equatable>(item: T, array:[T]) -> Int? 와 완전 동일
func findIndex(item: String, array:[String]) -> Int? {
    for (index, value) in array.enumerated() {
        if item.caseInsensitiveCompare(value) == .orderedSame {
            return index
        }
    }
    return nil
}

let aString = "jobs"
let someStringArray = ["Jobs", "Musk"]

if let index2 = findIndex(item: aString, array: someStringArray) {
    print("문자열의 비교:", index2)
}
```

<br/>

### 프로토콜에서의 제네릭 타입(연관타입)의 사용

> 프로토콜에서는 연관타입이라는 것을 사용해, 제네릭과 동일한 타입 파라미터를 지정합니다.

#### 1. 연관 타입의 지정

- 프로토콜에서는 연관타입(형식)으로 선언해야합니다.
  - <T> => associatedtype T
  - 프로토콜은 타입보다 한차원 높은 단계에서 요구사항을 선언하는 개념이기 때문에 제네릭 타입과는 또 다른 문법 개념입니다.
- associatedtype(연관타입)이라는 키워드를 쓰고, 옆에 타입 파라미터로 사용할 문자를 작성합니다.
  - 타입 파라미터는 대문자로 시작하면 상관없습니다.(예를 들어, <A>, <U>, <Element>, <T, U>) 
    - 관습적으로 Type(타입)의 의미인 대문자 T를 사용하지만, 다른 문자를 사용해도 됩니다.
  - **프로토콜을 채택하는 타입 내부에서 실제 타입으로 사용**됩니다.
- 제네릭처럼 타입을 제약할 수 있습니다. (예를 들면, associatedtype T: Equtable)

#### 2. 프로토콜의 채택 및 연관 타입의 사용

- typealias를 사용해서 명시적으로 타입을 표시(치환) 합니다. (생략도 가능합니다.)
- 생략가능하기 떄문에, 실제 타입을 구현한 함수 등에서 단순히 실제 타입을 사용하면 됩니다.

```swift
/**================================================
 - 프로토콜을 제네릭 방식으로 선언하려면 어떻게 해야할까?
 - 연관타입(Assiciated Types)으로 선언해야함 ⭐️
 
 - 프로토콜은 타입들이 채택할 수 있는 한차원 높은 단계에서
 요구사항만을 선언(자격증)하는 개념이기 때문에
 제네릭 타입과 조금 다른 개념(연관타입)을 추가적으로 도입한 것 뿐
 
 [프로토콜 방식]
 - <T> ===> associatedtype T
 =================================================**/
protocol RemoteControl {           // <T>의 방식이 아님
    associatedtype T               // 연관형식은 대문자로 시작해야함(UpperCamelcase)
    func changeChannel(to: T)      // 관습적으로 Element를 많이 사용
    func alert() -> T?
}

// 연관형식이 선언된 프로토콜을 채용한 타입은, typealias로 실제 형식을 표시해야함
struct TV: RemoteControl {
    typealias T = Int       // 생략 가능
    
    func changeChannel(to: Int) {
        print("TV 채널바꿈: \(to)")
    }
    
    func alert() -> Int? {
        return 1
    }
}

class Aircon: RemoteControl {
    // 연관형식이 추론됨
    func changeChannel(to: String) {
        print("Aircon 온도바꿈: \(to)")
    }
    
    func alert() -> String? {
        return "1"
    }
}
```

<br/>

## Result Type

> 성공 / 실패의 경우를 깔금하게 처리가 가능한 타입입니다.
>
> 기존의 예외처리 패턴을 완전히 대체하려는 목적이 아니라, 개발자에게 에러 처리에 대한 다양한 처리 방법에 대한 옵션을 제공합니다.

### Result Type에 대한 이해

- 에러가 발생하는 경우, 에러를 외부로 던지는 것이 아니라, 리턴 타입 자체를 Result Type(2가지를 다 담을 수 있는)으로 구현해서 함수 실행의 성공과 실패의 정보를 담아서 리턴합니다.
- 실제 Result 타입의 내부 구현
  - **enum Result<Success, Failure> where Failure: Error**
    - https://developer.apple.com/documentation/swift/result
  - Result 타입은 열거형입니다.
    - case success(연관값)
    - case failure(연관값)

<br/>

### 기존 에러 처리 vs Result 타입을 사용한 에러 처리

#### 기존 에러 처리

- **비정상적인 경우에 에러를 던지고**, 실제 함수를 호출하는 부분에서 try, do-catch 문으로 처리합니다.
- 단점으로, 실제 함수를 호출하는 곳에서 에러 형식을 특정짓기 어렵습니다.

```swift
// 에러 정의 (어떤 에러가 발생할지 경우를 미리 정의)
enum HeightError: Error {    //에러 프로토콜 채택 (약속)
    case maxHeight
    case minHeight
}

// throwing함수 (앞에서 배운)
func checkingHeight(height: Int) throws -> Bool {    // (에러를 던질 수 있는 함수 타입이다)
    if height > 190 {
        throw HeightError.maxHeight
    } else if height < 130 {
        throw HeightError.minHeight
    } else {
        if height >= 160 {
            return true
        } else {
            return false
        }
    }
}

// do - catch문을 사용하여 에러 구문 처리
do {
    let _ = try checkingHeight(height: 200)
    print("놀이기구 타는 것 가능")
} catch {
    print("놀이기구 타는 것 불가능")
}
```

#### Result 타입을 사용한 에러 처리

- 에러를 따로 던질 필요가 없기 때문에 **throws 키워드가 불필요합니다.**
- 리턴 타입이 **성공(정상적인 경우)**과 **실패(에러)**의 정보를 모두 담을 수 있는 열거형인 **Result Type으로 리턴**합니다.
- 장점으로, 실제 함수 정의 시에 에러 타입을 명시적 선언하기 때문에 타입캐스팅이 불필요합니다.

```swift
// 에러는 동일하기 정의되어 있다고 가정
// Result 타입에는 성공/실패했을 경우에 대한 정보가 다 들어있음
func resultTypeCheckingHeight(height: Int) -> Result<Bool, HeightError> {
    if height > 190 {
        return Result.failure(HeightError.maxHeight)
    } else if height < 130 {
        return Result.failure(HeightError.minHeight)
    } else {
        if height >= 160 {
            return Result.success(true)
        } else {
            return Result.success(false)
        }
    }
}

// 리턴값을 받아서
let result = resultTypeCheckingHeight(height: 160)

// 처리
switch result {
case .success(let data):
    print("결과값은 \(data)입니다.")
case .failure(let error):
    print(error)
}

// Result 타입에는 여러 메서드가 존재
// get() 메서드는 결과 값을 throwing함수처럼 변환 가능한 메서드 (Success 밸류를 리턴)
do {
    let data = try result.get()
    print("결과값은 \(data)입니다.")
} catch {
    print(error)
}
```

<br/>

### 네트워킹 코드에서 Result 타입 코드 예시

```swift
import Foundation

enum NetworkError: Error {
    case someError
}

// Result 타입 사용하기 전
// 튜플 타입을 활용, 데이터 전달
func performRequest(with url: String, completion: @escaping (Data?, NetworkError?) -> Void) {
    guard let url = URL(string: url) else { return }
    
    URLSession.shared.dataTask(with: url) { (data, response, error) in
        if error != nil {
            print(error!)                 // 에러가 발생했음을 출력
            completion(nil, .someError)   // 에러가 발생했으니, nil 전달
            return
        }
        
        guard let safeData = data else {
            completion(nil, .someError)   // 안전하게 옵셔널 바인딩을 하지 못했으니, 데이터는 nil 전달
            return
        }
        completion(safeData, nil)
    }.resume()
}

performRequest(with: "주소") { data, error in
    // 데이터를 받아서 처리
    if error != nil {
        print(error!)
    }
    
    // MARK: - 데이터 처리 관련 코드
}

// Result 타입 사용 후
func performRequest2(with urlString: String, completion: @escaping (Result<Data,NetworkError>) -> Void) {
    guard let url = URL(string: urlString) else { return }
    
    URLSession.shared.dataTask(with: url) { (data, response, error) in
        if error != nil {
            print(error!)                     // 에러가 발생했음을 출력
            completion(.failure(.someError))  // 실패 케이스 전달
            return
        }
        
        guard let safeData = data else {
            completion(.failure(.someError))   // 실패 케이스 전달
            return
        }
        completion(.success(safeData))      // 성공 케이스 전달
    }.resume()
}

performRequest2(with: "주소") { result in
    switch result {
    case .failure(let error):
        print(error)
    case .success(let data):
        // 데이터 처리 관련 코드
        break
    }
}
```

<br/>

## 접근 제어(Access Control)

### 접근 제어가 필요한 이유

- 외부에서, private으로 선언된 프로퍼티/메서드에 접근불가하므로 코드 내부의 세부 구현을 숨기는 것이 가능합니다. (객체지향에서 은닉화의 개념)
  - 아래 코드에서 name 프로퍼티는 외부에서 볼 수 없습니다. (접근할 수 없습니다.)
  - 코드의 영역을 분리시켜서 효율적으로 관리 가능합니다.
  - 컴파일 시간이 줄어듭니다. (컴파일러가, 해당 변수가 어느 범위에서만 쓰이는 지를 인지 가능합니다.)

```swift
class SomeClass {
    private var name = "이름"      // 내부적으로만 사용하겠다고 제한
    
    func nameChange(name: String) {
        if name == "길동" {
            return             // 어떤 로직을 넣을 수도 있음
        }
        self.name = name
    }
}
```

<br/>

### 접근제어 수준의 키워드

| 키워드      | 접근 수준에 대한 범위                                     | 비고                                                         |
| ----------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| open        | 다른 모듈에서 접근 가능(상속/재정의 가능) **(제한 낮음)** | 클래스의 가장 넓은 수준(클래스에서만 사용 가능)              |
| public      | 다른 모듈에서 접근 가능(상속/재정의 불가)                 | 구조체/열거형의 가장 넓은 수준(구조체는 상속 불가) 기본 타입의 설정 수준(Int, String) |
| internal    | 같은 모듈에서만 접근 가능(디폴트 설정)                    | 따로 명시하지 않는 경우의 기본 수준                          |
| fileprivate | 같은 파일 내에서만 접근 가능                              |                                                              |
| private     | 같은 scope 내에서만 접근 가능 **(제한 높음)**             |                                                              |

- 모듈(module): 프레임워크, 라이브러리, 앱 등 import해서 사용할 수 있는 외부의 코드
- 타입(클래스, 구조체, 열거형 등), 변수/프로퍼티, 함수/메서드(생성자, 서브스크립트), 프로토콜 등 특정영역에 제한됩니다. (모든 요소)

<br/>

### 접근 제어의 기본 원칙

> 타입은 타입을 사용하는 변수(프로퍼티)나, 함수(메서드)보다 높은 수준으로 선언되어야 합니다.

```swift
// String 타입은 public(접근 수준)
// some 변수는 internal(접근 수준)
var some: String = "접근가능"

// 함수 => internal접근 수준
internal func getSomething() -> Bool {
    print("hello") // 문자열(public 접근수준)
    return true
}
```

<br/>

### 읽기(getter) / 쓰기(setter) 중 쓰기의 제한을 높이는(접근 수준을 낮추는) 방법

```swift
// 실제 프로젝트에서 많이 사용하는 관습적인 패턴
// 프로퍼티(변수)를 선언시 private으로 외부에 감추려는 프로퍼티는 _(언더바)를 사용해서 이름 지음
class SomeOtherClass {
    private var _name = "이름"         // 쓰기 - private
    
    var name: String {                // 읽기 - internal
        return _name
    }
}

// 저장 프로퍼티의 (외부에서) 쓰기를 제한하기 ⭐️
class SomeAnotherClass {
    private(set) var name = "이름"      // 읽기 - internal / 쓰기 - private
}
```

<br/>

### 사용자 정의 타입(Custom)의 접근 제어

```swift
// 타입의 접근 제어 수준은 (해당 타입)멤버의 접근 제어 수준에 영향을 미침
// (예시) 타입이 internal 로 선언 되면 내부의 멤버는 internal이하(internal / fileprivate / private)로 설정됨
public class SomePublicClass {                         // 명시적인 public 선언
    open var someOpenProperty = "SomeOpen"             // open 이라고 설정해도 public으로 작동 ⭐️
    public var somePublicProperty = "SomePublic"
    var someInternalProperty = "SomeInternal"          // 원래의 기본 수준
    fileprivate var someFilePrivateProperty = "SomeFilePrivate"
    private var somePrivateProperty = "SomePrivate"
}

let somePublic = SomePublicClass()
somePublic.someOpenProperty
somePublic.somePublicProperty
somePublic.someInternalProperty
somePublic.someFilePrivateProperty                    // 같은 파일 안이기 때문에 접근 가능
//somePublic.somePrivateProperty
```

```swift
class SomeInternalClass {                             // 암시적인 internal 선언
    open var someOpenProperty = "SomeOpen"            // open 이라고 설정해도 internal으로 작동 ⭐️
    public var somePublicProperty = "SomePublic"
    var someInternalProperty = "SomeInternal"
    fileprivate var someFilePrivateProperty = "SomeFilePrivate"
    private var somePrivateProperty = "SomePrivate"
}

let someInternal = SomeInternalClass()
someInternal.someOpenProperty
someInternal.somePublicProperty
someInternal.someInternalProperty
someInternal.someFilePrivateProperty                 // 같은 파일 안이기 때문에 접근 가능
//someInternal.somePrivateProperty
```

```swift
fileprivate class SomeFilePrivateClass {             // 명시적인 file-private 선언
    open var someOpenProperty = "SomeOpen"
    public var somePublicProperty = "SomePublic"
    var someInternalProperty = "SomeInternal"
    var someFilePrivateProperty = "SomeFilePrivate"
    private var somePrivateProperty = "SomePrivate"
}

// 변수선언(internal) <===> 타입선언(fileprivate)은 불가능 (fileprivate / private 선언가능)
//internal let someFilePrivate = SomeFilePrivateClass()
fileprivate let someFilePrivate = SomeFilePrivateClass()
someFilePrivate.someOpenProperty                    // fileprivate
someFilePrivate.somePublicProperty                  // fileprivate
someFilePrivate.someInternalProperty                // fileprivate
someFilePrivate.someFilePrivateProperty             // 같은 파일 안이기 때문에 접근 가능
//someFilePrivate.somePrivateProperty
```

```swift
// 타입을 private으로 선언하면 아무곳에서도 사용할 수 없기 때문에 의미가 없음 ⭐️
private class SomePrivateClass {                    // 명시적인 private 선언
    open var someOpenProperty = "SomeOpen"
    public var somePublicProperty = "SomePublic"
    var someInternalProperty = "SomeInternal"
    var someFilePrivateProperty = "SomeFilePrivate"     // 실제 fileprivate 처럼 동작 ⭐️ (공식문서 오류)
    private var somePrivateProperty = "SomePrivate"
}

fileprivate let somePrivate = SomePrivateClass()
somePrivate.someOpenProperty
somePrivate.somePublicProperty
somePrivate.someInternalProperty
somePrivate.someFilePrivateProperty             // 같은 파일 안이기 때문에 접근 가능
//somePrivate.somePrivateProperty
```

```swift
// 타입의 접근 수준이 높다고, 내부 멤버의 접근 수준이 무조건 따라서 높아지는 것 아님
open class SomeClass {
    var someProperty = "SomeInternal"
    // internal 임 ➞ 클래스와 동일한 수준을 유지하려면 명시적으로 open선언 필요
}
```

<br/>

### 상속 관계(Subclassing)의 접근 제어

- 상속 관계 주의점
  1. 타입 관련: 상속해서 만든 하위 클래스는 상위 클래스보다 더 높은 접근 수준이 안됩니다.
  2. 맴버 관련: 동일 모듈에서 정의한 클래스의 상위 맴버에 접근하면, (접근 수준 올려서) 재정의 가능합니다.
     - 예시) 상위 맴버(fileprivate) --> 하위 맴버(internal)로 재정의 가능(호출가능하기 때문)

```swift
public class A {
    fileprivate func someMethod() {}
}


// public 이하의 접근 수준만 가능(public/internal/fileprivate)
internal class B: A {
    override internal func someMethod() {   // 접근 수준 올려서 재정의 가능 ⭐️
        super.someMethod()                  // (더 낮아도) 모듈에서 접근가능하기 때문에 호출가능
    }
}
```

<br/>

### 확장(Extension)의 접근 제어

```swift
// 기본법칙 - 원래 본체와 동일한 접근 수준을 유지하고, 본체의 멤버에는 기본적인 접근 가능
public class SomeClass {
    private var somePrivateProperty = "somePrivate"
}


extension SomeClass {   // public으로 선언한 것과 같음
    func somePrivateControlFunction() {
        somePrivateProperty = "접근가능"
    }
}
```

<br/>

### 프로퍼티의 읽기 설정(getter)과 프로퍼티의 쓰기 설정(setter)의 접근제어 (계산 프로퍼티를 말하는 것 아님)

```swift
// 일반적으로 밖에서 쓰는 것(setter)은 불가능하도록 구현하는 경우가 많음
struct TrackedString {
    //var numberOfEdits = 0                   // 외부에서도 변경가능
    //private var numberOfEdits = 0           // 이렇게 선언하면, 읽기도 불가능해짐
    private(set) var numberOfEdits = 0        // setter에 대해서만 private 선언 ⭐️
    //internal private(set) var numberOfEdits = 0
    
    // 프로퍼티 관찰자
    var value: String = "시작" {
        didSet {
            numberOfEdits += 1
        }
    }
}

var stringToEdit = TrackedString()
stringToEdit.value = "첫설정"
stringToEdit.value += " 추가하기1"
stringToEdit.value += " 추가하기2"
stringToEdit.value += " 추가하기3"
print("수정한 횟수: \(stringToEdit.numberOfEdits)")
print(stringToEdit.value)


// 외부에서 직접 설정하는 것은 불가능 (읽는 것은 가능) ⭐️
//stringToEdit.numberOfEdits = 3

// 프로퍼티의 읽기설정과 프로퍼티의 쓰기설정에 대해 각각 명시적으로 선언도 가능
/**=======================================================
 - 변수 및 프로퍼티, 서브스크립트에 쓰기(setter)수준을 읽기(getter)수준
   보다 낮은 접근 수준으로 설정 가능
 
 - internal private(set) var numberOfEdits = 0 이라고 선언하면
 
 - 1) 프로퍼티의 읽기설정(getter)은 - internal
 - 2) 프로퍼티의 쓰기설정(setter)은 - private(set)
 
 - 저장프로퍼티/계산프로퍼티 모두에 설정 가능
 =========================================================**/
```

<br/>

## 문자열과 문자(Strings and Character)

### 아스키코드(ASCII Code)와 유니코드(Unicode)

#### 1. **아스키코드(ASCII Code)**

- **개념**: 아스키코드는 7비트 또는 8비트 문자 인코딩으로, 기본적으로 영문자, 숫자, 특수문자 등을 표현합니다. 0-127까지 총 128개의 문자를 표현할 수 있어, 주로 영문 기반의 간단한 텍스트에 사용됩니다.
- **Swift에서 사용**: Swift에서 `Character`를 아스키코드로 변환할 때는 `asciiValue`를 사용하여 값을 확인합니다. 예를 들어, `'A'`의 아스키코드는 65입니다.

```swift
let character: Character = "A"
if let asciiValue = character.asciiValue {
    print(asciiValue)  // 65
}
```

#### 2. **유니코드(Unicode)**

- **개념**: 유니코드는 전 세계의 모든 문자와 심볼을 표현할 수 있는 표준입니다. 각 문자는 고유한 `유니코드 포인트`를 가지며, Swift에서 `UTF-8`, `UTF-16`, `UTF-32` 형식으로 인코딩됩니다.
- **Swift에서 사용**: `String`이나 `Character`를 유니코드 값으로 변환하려면 `unicodeScalars`를 사용하여 유니코드 포인트를 확인할 수 있습니다. 예를 들어, 이모지 '😊'는 유니코드 128522를 가집니다.

```swift
let emoji: Character = "😊"
for scalar in emoji.unicodeScalars {
    print(scalar.value)  // 128522
}
```

```swift
/**===========================================================================
 - 스위프트의 문자열(String)?
 - 쌍따옴표 안에 문자(Character)들을 연결
 
 - 모든 문자열은 개별 인코딩된 유니코드 문자들(encoding-independent Unicode characters)로 구성
 - 유니코드 값(코드포인트 - 스칼라값)
 
 - 결국, 스위프트는 문자열을 저장할때, 하나의 문자를 유니코드의 스칼라값(UTF-32)으로 저장
 그리고 언제든지 UTF-8, UTF-16방식으로도 쉽게 변환할 수 있는 방법도 제공해줌
 1) 문자열.unicodeScalars
 2) 문자열.utf8
 3) 문자열.utf16
 ==============================================================================**/

var someString: String = "Some Swift😃"

// 문자열은 결국, 각 문자를 모아놓은 데이터 바구니
for code in someString.unicodeScalars {
    print(code.value)
}

/**=====================================
 - 문자열    UTF-32값         (16진법 표현)
 - "S"     -   83   ====>    53 (16진법)
 - "o"     -  111   ====>    6F (16진법)
 - "m"     -  109   ====>    6D (16진법)
 - "e"     -  101   ====>    65 (16진법)
 - " "     -   32   ====>    20 (16진법)
 - "S"     -   83   ====>    53 (16진법)
 - "w"     -  119   ====>    77 (16진법)
 - "i"     -  105   ====>    69 (16진법)
 - "f"     -  102   ====>    66 (16진법)
 - "t"     -  116   ====>    74 (16진법)
 - "😃"    -128515  ====> 1F603 (16진법)
 ========================================**/
someString = "\u{53}\u{6F}\u{6D}\u{65}\u{20}\u{53}\u{77}\u{69}\u{66}\u{74}\u{1F603}"
print(someString) // Some Swift😃
```

#### 3. **아스키코드와 유니코드의 차이점**

- **범위**: 아스키코드는 128개의 문자만 지원하는 반면, 유니코드는 거의 모든 언어의 문자 및 특수문자를 포함합니다.
- **호환성**: 유니코드는 아스키코드를 포함하므로, 아스키 기반의 문자 처리에서 유니코드 기반으로의 확장이 용이합니다.
- **표현 방식**: 아스키코드는 8비트로 표현되며, 유니코드는 주로 가변 길이 인코딩 방식(UTF-8, UTF-16 등)을 사용해 더 다양한 문자를 표현합니다.

#### 4. 유니코드로 인한 Swift 문자열의 특징과 주의점

- Swift의 문자열에서는 배열같은 단순 인덱스(index) 접근이 불가능합니다. ⭐️
  - Swift는 문자열을 글자의 의미단위로 사용하기 때문에, 정수 인덱스 사용이 불가능합니다.
  - 0, 1, 2, 3, 4 .... (X)

```swift
var hangul1 = "\u{D55C}"     // "한"
print("\"한\"의 글자수: ", hangul1.count)

var hangul2 = "\u{1112}\u{1161}\u{11AB}"      // "ㅎ" "ㅏ" "ㄴ"
print("\"ㅎ\"+\"ㅏ\"+\"ㄴ\"의 글자수: ", hangul2.count)

hangul1 == hangul2 // true 
// 한글과 같은 언어들을 "ㅎ" "ㅏ" "ㄴ" 내부적으로 하나의 글자로 취급 ⭐️

var word = "cafe"
print("글자의 숫자 \(word) is \(word.count)")
// "글자의 숫자 cafe is 4"

word += "\u{301}"    // COMBINING ACUTE ACCENT, U+0301
print("글자의 숫자 \(word) is \(word.count)")
// "글자의 숫자 café is 4"
```

<br/>

### Swift의 문자열 - String / NSString

```swift
/**===============================================================
 - 스위프트에서는 2개의 문자열 자료형을 사용

 - 문자열 내부적으로 서로 연동(bridged)
 - 1) String ▶︎ Swift String  구조체/값형식 (스위프트 문자열)
 - 2) NSString ▶︎ Foundation String  클래스/참조형식  (파운데이션 문자열)
==================================================================**/
var nsString: NSString = "Swift"   // 문제없이 저장

//let string: String = nsString   // 에러발생
let string: String = nsString as String
// String <===> NSString간에 자동으로 변환컨버팅되지는 않음(타입캐스팅해야함)

nsString.length       // NSString의 length속성 ===> 유니코드수(UTF-16) 기반
string.count          // String의    count속성 ===> 의미 글자수 기반

nsString = string as NSString    // 두형식은 브릿징이 가능한 타입 (Toll-Free Bidged) ===> 타입캐스팅으로 호환되는 자료형

// 두 자료형은 서로 호환되는 자료형이지만, 유니코드를 처리하는 방식이 달라서, 조심해서 사용해야함 ⭐️
// word = café 라는 단어가 저장되어 있음
let nsWord = word as NSString

word.count // 4
nsWord.length // 5

// NSString은 Objected-C에서 사용하는 문자열이고
// NSString에서 더 파생된 개념인 NSAttributedString을 실제 앱을 만들때, 간혹가다 사용하는 경우가 있음
// 문자열에 클릭기능을 넣는다던지. 글자별로 색깔을 다르게 한다던지
```

<br/>

### 멀티라인 스트링 리터럴(Multiline String Literals)

- 문자열을 한줄에 입력 -> 명시적인 줄바꿈이 불가능

```swift
let singleLineString = "These are \nthe same."       // 줄바꿈을 원하면, \n 입력   \ (Escape character)
print(singleLineString)
// These are
// the same.

/**===========================================================
 - 문자열을 여러줄 입력하고 싶을때
 - 1) """ (쌍따옴표 3개를 연속으로 붙여서 입력) - 첫째줄/마지막줄에 입력
 - 2) 해당줄에는 문자열 입력 불가
 - 3) 문자열 내부에서 쓰여진대로 줄바꿈됨. ===> (줄바꿈 하지 않으려면 \(백슬레시) 입력)
 - 4) 특수문자는 문자 그대로 입력됨
 - 5) 마지막(""")는 들여쓰기의 기준의 역할
=============================================================**/
let quotation = """
The White Rabbit put on his spectacles.  "Where shall I begin,
please your Majesty?" he asked.

"Begin at the beginning," the King said gravely, "and go on
till you come to the end; then stop."
"""
print(quotation)
```

### 문자열 내에서 특수문자 (Escape sequences)

```swift
/**==============================
 [Escape character sequences]
 - \0  (null문자)
 - \\  (백슬레시)
 - \t  (탭)
 - \n  (줄바꿈 - 개행문자)
 - \r  (캐리지 리턴 - 앞줄이동)
 - \"  (쌍따옴표)
 - \'  (작은따옴표)
 - \u{유니코드값}   (1~8자리의 16진수)
=================================**/

let wiseWords = "\"Imagination is more important than knowledge\" - Einstein"
print(wiseWords)
```

### 로스트링(Raw String) - 확장 구분자(Extended String Delimiters)

- 문자열 내에서 특수문자를 많이 써야하는 상황이라면, 글자 날것 그대로 표현하는 것이 코드에서 덜 헷갈릴 수 있음
- 샵 기호(#)으로 문자열 앞뒤를 감싸면 내부의 문자열을 글자 그대로 인식

```swift
// 샵의 갯수를 개발자 임의로 조절 가능
var name = #"Steve"#
print(name)

let string1 = #"Line 1\nLine 2"#       // 특수문자가 그대로 인식됨
print(string1)

let string2 = #"Line 1\#nLine 2"#
print(string2)

let string3 = ###"Line 1\###nLine 2"###
print(string3)

let string4 = #"My name is \#(name)"#         // 이스케이프 시퀀스 효과를 사용하려면, 샵을 입력
let threeMoreDoubleQuotationMarks = #"""
Here are three more double quotes: """
"""#

print(threeMoreDoubleQuotationMarks)
```

<br/>

### 문자열 보간법

#### String Interpolation(스트링 인터폴레이션)

- 문자열 리터럴 내에서 `"..\(표현식).."`
- **CustomStringConvertible** 프로토콜의 **description** 읽기 계산 속성을 읽음 ( ~ Swift 4 )

```swift
struct Dog {
    var name: String
    var weight: Double
}

let dog = Dog(name: "초코", weight: 15.0)
print("\(dog)")      // 강아지의 이름은 초코이고, 몸무게는 15.0입니다. --> \() => description 변수를 읽는 것

extension Dog: CustomStringConvertible {
    var description: String {
        return "강아지의 이름은 \(name)이고, 몸무게는 \(weight)kg 입니다."
    }
}
```

- **String.StringInterpolation**의 **appendInterpolation() 메서드** 실행 ( ~ Swift 5 )

```swift
struct Point {
    let x: Int
    let y: Int
}

let p = Point(x: 5, y: 7)
print("\(p)") // X좌표는 5, Y좌표는 7입니다. --> \() ====> appendInterpolation()을 실행

extension String.StringInterpolation {
    mutating func appendInterpolation(_ value: Point) {
        appendInterpolation("X좌표는 \(value.x), Y좌표는 \(value.y)입니다.")
    }
}
```

### 숫자의 문자의 변환

#### 출력형식 지정자 (Format Specifiers)

| 형식 지정 (Format Specifiers) | 의미                       |
| ----------------------------- | -------------------------- |
| "%f"                          | 실수형 형식                |
| "%.2f"                        | 소수점 2자리               |
| "%.3f"                        | 소수점 3자리               |
| "%d"                          | 정수형 형식                |
| "02d"                         | 2자리, 0포함               |
| "%07.3f"                      | 7자리, 0포함, 소수점 3자리 |
| "%@"                          | 문자열 형식                |
| "%1$@"                        | 문자열 첫번째 파라미터     |

- 코드 예시

```swift
// 단순 출력
var pi = 3.1415926
print("원하는 숫자는 \(pi)")

// 실제 앱 구현시, 반올림등을 상황이 자주 발생
// "원하는 숫자는 3.14" 라고 출력해야하는 경우 ⭐️

/**=================================
출력 형식 지정자(Format Specifiers)
===================================**/
// 문자열 생성자를 활용하는 방법
var string: String = ""

string = String(3.1415926)
print(string)

string = "원하는 숫자는 " + String(format: "%.3f", pi)  // 반올림
print(string) // 원하는 숫자는 3.142

string = "원하는 숫자는 " + String(format: "%.2f", pi)
print(string) // 원하는 숫자는 3.14

string = "원하는 숫자는 " + String(format: "%.1f", pi)
print(string) // 원하는 숫자는 3.1

string = String(format: "원하는 숫자는 %.2f", pi)       // %.2f 자리에 pi를 대체
print(string) // 원하는 숫자는 3.14

/**=================================
출력 형식 지정자(Format Specifiers)의 종류
===================================**/
string = String(format: "%d", 7)           // %d, %D   ===> 정수
print(string) // 7

string = String(format: "%2d", 7)          // 두자리로 표현
print(string) //  7

string = String(format: "%02d", 7)         // 두자리로 표현하되, 0포함
print(string) // 07

string = String(format: "%07.3f", pi)      // 일곱자리로 표현하되 0과 .(dot) 포함, (소수점아래는 3자리)
print(string) // 003.142

var swift = "Swift"
string = String(format: "Hello, %@", swift)       // %@  ===> 문자열
print(string) // Hello, Swift
```

### NumberFormatter - 숫자의 문자 변환을 돕는 클래스

> NumberFormatter() ==> 미리 (변환을) 원하는 형식 지정 가능

- `.roundingMode` 반올림모드
- `.maximumSignificantDigits` 최대자릿수
- `.minimumSignificantDigits` 최소자릿수
- `.numberStyle` 숫자스타일

- 코드 예시

```swift
// 소수점 버리기
let numberFormatter = NumberFormatter()
numberFormatter.roundingMode = .floor         // 버림으로 지정
numberFormatter.maximumSignificantDigits = 3  // 최대 표현하길 원하는 자릿수

let value = 3.1415926
var valueFormatted = numberFormatter.string(for: value)!    // 문자열화시키는 메서드
print(valueFormatted)   // 3.14

// 소수점 필수적 표현하기
numberFormatter.roundingMode = .floor         // 버림으로 지정
numberFormatter.minimumSignificantDigits = 4  // 최소 표현하길 원하는 자릿수

let value2 = 3.1
valueFormatted = numberFormatter.string(for: value2)!     // 문자열화시키는 메서드
print(valueFormatted)     // 3.100

// 세자리수마다 콤마 넣기 ⭐️
numberFormatter.numberStyle = .decimal
let price = 10000000
let result = numberFormatter.string(for: price)!
print(result) // "10,000,000"
```

<br/>

### 문자열을 배열로 변환 - 문자열도 데이터 바구니의 개념이기에 쉽게 배열로 변환 가능

- 문자열 <====> 배열
  - `문자열.map { String($0) }` <====> `[문자열]배열.joined()`
  - `Array(문자열)` <====> `String([문자]배열)`
- 코드 예시

```swift
/**============================================
 - 문자열 자체도, 여러개의 문자를 담고 있는 데이터이기 때문에
   쉽게 배열로 변형이 가능하고, 반대 변형도 쉬움
 
 -  String    <====>  [String]   문자열 배열
 -  String    <====> [Character] 문자 배열
 ============================================**/
var someString = "Swift"

// 1) 문자열을 문자열(String) 배열화 하기 ⭐️
var array: [String] = someString.map { String($0) }
print(array)

// 2) 문자열을 문자(Character) 배열화 하기
var array2: [Character] = Array(someString)     // [Character]      //typealias Element = Character

// (참고) 문자열을 문자열(String) 배열화하는 추가적 방법
var array3: [String] = Array(arrayLiteral: someString)  // [String]

// 3) 문자열 배열 [String] =====> 문자열
var newString = array.joined()
newString = array3.joined()

// 4) 문자 배열  [Character] ======> 문자열
var newString2 = String(array2)
/**============================
(활용 예시) 문자열을 뒤죽박죽 섞는다면?
 ==============================**/
someString = "Swift"

someString.randomElement()     // 문자열에서 랜덤으로 뽑아내는 것 가능
someString.shuffled()          // 섞어서 문자(Character) 배열로 리턴 ["t", "i", "w", "S", "f"]
//someString.shuffled().joined()     // 불가능 (문자 배열 이기 때문에)

var newString3 = String(someString.shuffled())
print(newString3)

// map고차함수를 사용해서 변환 ⭐️
newString3 = someString.map { String($0) }.shuffled().joined()
print(newString3)
```

### 문자열의 대소문자 변형

- Swift는 대문자와 소문자를 다른 문자로 인식(유니코드 다름)

```swift
var string = "swift"

string.lowercased()    // 전체 소문자로 바꾼 문자열 리턴 (원본 그대로)
string.uppercased()    // 전체 대문자로 바꾼 문자열 리턴 (원본 그대로)
string.capitalized     // 대문자로 시작하는 글자로 리턴하는 속성 (원본 그대로)
//"swift".capitalized

// 소문자로 변형시키서 비교하는 것은 가능
"swift" == "Swift"   // false
"swift".lowercased() == "Swift".lowercased()    // true
```

### 문자열 다루기 기본 - count, isEmpty 속성

```swift
var emptyString = " "    // [공백]이 포함된 문자열

// 문자열은 길이를 기준으로 빈문장열을 판단
emptyString.count     // 1
emptyString.isEmpty   // false

emptyString = ""     // [빈] 문자열    (nil이 절대 아님)
emptyString.count        // 0
emptyString.isEmpty      // true

if emptyString == nil {    // 빈 문자열은 nil이 아님 ===> String타입 (O)   String?타입 (X)
    print("nil")
}
```

### String의 인덱스(색인/순번) 타입

```swift
import Foundation
/**============================================================
 - 문자열의 인덱스는 정수가 아님 ⭐️
 - (스위프트는 문자열을 글자의 의미단위로 사용하기 때문에, 정수 인덱스 사용 불가)
 
 [String.Index 타입]
 - 문자열.startIndex
 - 문자열.endIndex
 - 문자열.index(<#T##i: String.Index##String.Index#>, offsetBy: <#T##String.IndexDistance#>)
 
 - 문자열.index(after: <#T##String.Index#>)
 - 문자열.index(before: <#T##String.Index#>)
 - (다만, 인덱스의 크기 비교는 당연히 가능)
 
 - 문자열.indices     (인덱스의 모음)
 - (인덱스를 벗어나는 것에 주의)
 
 - 문자열.firstIndex(of: <#T##Character#>)
 - 문자열.lastIndex(of: <#T##Character#>)
 
 [String.Index 범위]
 - 문자열.range(of: <#T##StringProtocol#>)
 - 문자열.range(of: <#T##StringProtocol#>, options: <#T##String.CompareOptions#>, range: <#T##Range<String.Index>?#>, locale: <#T##Locale?#>)
 
 - String.Index를 이용, 서브스크립트 활용가능 ⭐️
 
 [String.Index의 정수형태로 거리는 측정 가능]
 - 문자열.distance(from: <#T##String.Index#>, to: <#T##String.Index#>)
 ==============================================================**/

let greeting = "Guten Tag!"
greeting.startIndex
print(greeting.startIndex)
greeting[greeting.startIndex]    // "G"

// 정수형태를 한번 변형해서(걸러서) 사용하는 방식 ⭐️
var someIndex = greeting.index(greeting.startIndex, offsetBy: 2)
greeting[someIndex]      // "t"

someIndex = greeting.index(greeting.startIndex, offsetBy: 1)
greeting[someIndex]      // "u"

someIndex = greeting.index(after: greeting.startIndex)
greeting[someIndex]      // "u"

someIndex = greeting.index(before: greeting.endIndex)
greeting[someIndex]      // "!"

for index in greeting.indices {       // 개별 문자의 인덱스에 접근
    print("\(greeting[index]) ", terminator: "")
}
print("")

//======================================== 출력결과는 동일하지만 접근법이 다름
for char in greeting {
    print("\(char) ", terminator: "")
}
//========================================

// 공백 문자열 다음의 글자를 알고 싶을때
var firstIndex = greeting.firstIndex(of: " ")!
var nextOfEmptyIndex = greeting.index(firstIndex, offsetBy: 1)
greeting[nextOfEmptyIndex]

// 세번째 글자를 알고 싶을때
var thirdCharIndex  = greeting.index(greeting.startIndex, offsetBy: 2)           // 스타트 인덱스에서 2만큼 이동한 인덱스로
var thirdCh = greeting[thirdCharIndex]

// 범위를 벗어나면 에러발생 주의 ⭐️
//greeting[greeting.endIndex]
greeting[greeting.index(greeting.endIndex, offsetBy: -1)]
//greeting[greeting.index(before: greeting.endIndex)]

// 예를 들자면, 아래와 같이 올바른 범위에서 실행
someIndex = greeting.index(greeting.startIndex, offsetBy: 7)

if greeting.startIndex <= someIndex && someIndex < greeting.endIndex { // 범위를 벗어나지 않는 경우 코드 실행
    print(greeting[someIndex])
}

// indices를 직접 출력해보기
for i in greeting.indices {
    print(i)
}

// let greeting = "Guten Tag!"
// 문자열 특정범위를 추출
let lower = greeting.index(greeting.startIndex, offsetBy: 2)
let upper = greeting.index(greeting.startIndex, offsetBy: 5)
greeting[lower...upper]

// 실제로는 뒤에서 배울, 교체/삭제에서 주로 범위를 활용
var range = greeting.range(of: "Tag!")!
greeting[range]
range = greeting.range(of: "tag", options: [.caseInsensitive])!
greeting[range]

// 정수 형태 수치로 거리 측정
var distance = greeting.distance(from: lower, to: upper)
print(distance)
```

<br/>

## 문자열 - 삽입 교체 추가 삭제

### 삽입하기(insert)

- `insert(_*:,at:)` // 특정인덱스에 문자
- `insert(contentsOf:,at:)` // 특정인덱스에 문자열

```swift
var welcome = "Hello"

welcome.insert("!", at: welcome.endIndex)
// "Hello!"

welcome.insert(contentsOf: " there", at: welcome.index(before: welcome.endIndex))
// "Hello there!"
```

### 교체하기(replace)

- `replaceSubrange(_:,with:)` // 범위기준 교체
- `replacingOccurrences(of:,with:)` // (존재하면) 해당글자가 있으면 교체 ==> 원본은 그대로
- `replacingOccurrences(of:,with:,options:,range:)`

```swift
var welcome = "Hello there!"
print(welcome) // Hello there!

if let range = welcome.range(of: " there!") {  // 범위를 가지고
    welcome.replaceSubrange(range, with: " Swift!")     // 교체하기
    print(welcome) // Hello Swift!
}

// 교체하되, 문자열 원본은 그대로 (occurrence: 존재하는)
var newWelcome = welcome.replacingOccurrences(of: "Swift", with: "World")

// "Swift"라는 문자열이 존재하면, "World"로 교체
print(welcome) // Hello Swift!
print(newWelcome) // Hello World!

// 대소문자 무시 옵션
newWelcome = welcome.replacingOccurrences(of: "swift", with: "New World", options: [.caseInsensitive], range: nil)
print(welcome) // Hello Swift!
print(newWelcome) // Hello New World!
```

### 추가하기(append)

- 문자열 기본 연산자 + / +=
- `append(_:)`

```swift
var welcome = "Hello Swift!"

"swift" + "!"  // 너무나 당연
welcome.append("!") // Hello Swift!!
welcome.append(" Awesome!") // Hello Swift!! Awesome!
```

### 삭제(제거)하기(remove)

- `remove(at:)` // 특정인덱스의 문자
- `removeSubrange(_:)` // 특정인덱스의 문자열

```swift
import Foundation

var welcome = "Hello Swift!"

// 인덱스를 가지고 지우기
// (endIndex의 전 인덱스)
welcome.remove(at: welcome.index(before: welcome.endIndex))     // "!" 지우기
welcome // "Hello Swift"

// 인덱스 범위파악
var range = welcome.index(welcome.endIndex, offsetBy: -6)..<welcome.endIndex
//range = welcome.range(of: " Swift")!

// " Swift"의 범위를 파악하고 지우기
welcome.removeSubrange(range)
welcome      // "Hello"

// 문자열을 모두 삭제 / 메모리 공간은 유지할 것인지
welcome.removeAll()
welcome.removeAll(keepingCapacity: true)
```

### 문자열 삽입과 삭제의 활용

```swift
var string = "Hello world"

// 1) " " 공백 문자열의 인덱스 찾기
// 2) " " 공백 문자열의 인덱스에 " super" 삽입하기
if let someIndex = string.firstIndex(of: " ") {
    string.insert(contentsOf: " super", at: someIndex)
    print(string)      // "Hello super world"
}

// 1) 첫 " " 공백 문자열의 인덱스 찾기
// 2) " super" 문자열의 범위 만들기
// 3) 범위 삭제하기
if let firstIndex = string.firstIndex(of: " ") {
    let range = firstIndex...string.index(firstIndex, offsetBy: 5)
    string.removeSubrange(range)
    print(string)     // "Hello world"
}

// 바꿀 문자열을 정확하게 알고 있다면 ===> 범위를 직접 리턴하는 메서드 활용 ⭐️
if let range = string.range(of: " world") {
    string.removeSubrange(range)
    print(string) // "Hello"
}
```

<br/>

## 문자열 비교하기

### 문자열의 단순 비교

```swift
// 비교연산자 (대소문자 구별)
"swift" == "Swift"   // false
"swift" != "Swift"   // true   ===> 둘의 문자는 다른 것임

// 크기 비교하기 (유니코드 비교)
"swift" < "Swift"      // false ====> 첫 글자의 (유니코드) 순서를 비교
"swift" <= "Swift"     // false ====> 소문자가 (유니코드/아스키코드) 더 뒤에 위치
//"Swift" <= "swift"     // true

// 대소문자 무시하고 비교는?
// (간단하게는 일치시킨 후 비교)
"swift".lowercased() == "Swift".lowercased()
/**========================================================
대소문자무시하고 비교하는 메서드 존재 → caseInsensitiveCompare(문자열)
===========================================================**/
var a = "swift"
var b = "Swift"

a.caseInsensitiveCompare(b) == ComparisonResult.orderedSame // true

/**========================================================
 ComparisonResult 열거형 타입으로 정의  (비교 결과 타입)
  1) .orderedSame          // 동일
  2) .orderedAscending     // 오름차순
  3) .orderedDescending    // 내림차순
 
 - 단순 같은지 틀린지 뿐만아니라, 결과가 오름차순/내림차순인지
   내림차순인지 알수 있어서 결과값이 활용성이 높고 보다 구체적인 정보 제공가능 ⭐️
   (다만, 처음 사용하는 입장에서 헷갈릴 수 있으므로 잘 알고
   사용해야하는 불편함이 있을 수 있음)
===========================================================**/
```

## 문자열 비교 메서드

### 문자열에서 일치여부 확인 메서드 사용

- "다양한 옵션" 적용이 가능해서 비교를 여러가지 방식으로 활용가능

```swift
// 문자열.compare(_:options:range:locale:) ⭐️

var name = "Hello, Swift"
name.compare("hello", options: [.caseInsensitive]) == .orderedDescending    // 내림차순  ( , ==>  )
```

### 문자열 비교 옵션(String.CompareOptions)과 비교 결과

```swift
// String.CompareOptions (비교 옵션)
/**==========================================
 [String.CompareOptions 구조체]와 내부의 타입 속성들
 - .caseInsensitive       // 대소문자 무시하고 ⭐️
 
 - .diacriticInsensitive  // 발음구별기호 무시하고
 - .widthInsensitive      // 글자 넓이 무시하고
 
 - .forcedOrdering        // 강제적 오름차순/내림차순 정렬순 (대소문자 무조건 구별 의미)
 - .literal               // (유지코드 자체로) 글자그대로
 - .numeric               // 숫자 전체를 인식해서 비교
 
 - .anchored              // (앞부분부터) 고정시키고 (접두어)
 - .backwards             // 문자 뒷자리부터

 - .regularExpression     // 정규식 검증 ⭐️
=============================================**/

// 옵션 입력 부분
// OptionSet 프로토콜 채택시, 여러개의 옵션을 배열 형식으로 전달 가능
//NSString.CompareOptions
/**==========================================
 struct CompareOptions : OptionSet   프로토콜 채택
=============================================**/

// .diacriticInsensitive 발음구별기호 무시하고
"café".compare("cafe", options: [.diacriticInsensitive]) == .orderedSame

// .widthInsensitive 글자 넓이 무시하고
"ァ".compare("ｧ", options: [.widthInsensitive]) == .orderedSame

// .forcedOrdering 강제적 오름차순/내림차순 정렬순 (대소문자 무조건 구별 의미)
"Hello".compare("hello", options: [.forcedOrdering, .caseInsensitive]) == .orderedAscending

// .numeric 옵션 숫자 전체를 인식해서 비교
"album_photo9.jpg".compare("album_photo10.jpg", options: [.numeric]) == .orderedAscending

// .literal 옵션
"\u{D55C}".compare("\u{1112}\u{1161}\u{11AB}", options: [.literal]) == .orderedSame
// "한"(완성형)     "ㅎ+ㅏ+ㄴ"(조합형)

// .anchored 옵션 (앞부분부터) 고정시키고 (접두어)
if let _ = "Hello, Swift".range(of: "Hello", options: [.anchored]) {   // 범위리턴 ===> 접두어 기능
    print("접두어 일치")
}

// .anchored 옵션 + .backwards 뒷자리부터 고정 (접미어)
if let _ = "Hello, Swift".range(of: "Swift", options: [.anchored, .backwards]) {   // ===> 접미어 기능
    print("접미어 일치")
}
```

<br/>

## 문자열 (일부)포함여부 및 앞/뒤 글자의 반환

### 문자열에서 일치여부 확인하기

```swift
let string = "Hello, world!"

// 전체문자열에서 포함여부
string.contains("Hello") // true
string.lowercased().contains("hello") // true
string.contains("world") // true

// 접두어/접미어 포함여부
string.hasPrefix("Hello") // true
string.hasPrefix("world") // false 
string.lowercased().hasPrefix("world") // false

string.hasSuffix("!") // true
string.hasSuffix("world!") // true

// 접두어/접미어 반환 (앞에서 또는 뒤에서 몇글자 뽑아내기)
string.prefix(2) // "He"
string.suffix(3) // "ld!"

// 공통 접두어 반환
string.commonPrefix(with: "Hello, swift") // "Hello,"
string.commonPrefix(with: "hello", options: [.caseInsensitive]) // "Hello"

// 앞/뒤를 drop시킨 나머지 반환
string.dropFirst(3) // "llo, world!"
string.dropLast(3) // "Hello, wor"
```

<br/>

## 정규식 / 정규표현식

### 정규식(정규표현식)을 이용한 문자열의 판별

- **정규식(正規式)은 "특정한 규칙"을 가진 문자열의 집합을 표현하는 데 사용하는 형식 언어**

```swift
// (스위프트에만 해당하는 것이 아님)
// 올바른 전화번호 형식일까?
// (정규식 확인하는 코드)
let number = "010-1234-1234"

// 정규식 (RawString으로 작성하면 메타문자를 바로 입력가능) ===> 가독성 높아짐
// (스위프트에서는 \ 백슬레시를 이스케이프 문자로 인식하기 때문)
var telephoneNumRegex = #"[0-9]{3}[- .]?[0-9]{4}[- .]?[0-9]{4}$"#

if let _ = number.range(of: telephoneNumRegex, options: [.regularExpression]) {
    print("유효한 전화번호로 판단")
}

// 정규식에 대한 내용을 찾으려면, 구글 및 유튜브 검색 및 활용
/**=========================================================**/
  #"[0-9]{3}[- .]?[0-9]{4}[- .]?[0-9]{4}"#   // 전화번호 러프하게
  #".*@.*\..*"#                              // 이메일 러프하게
  #"[0-9]{3}\-[0-9]{3}"#                     // 우편번호 러프하게
/**=========================================================**/

// 참고
// https://www.youtube.com/watch?v=Gg0tlbrxJSc
// https://www.youtube.com/watch?v=-5cnj7q1-YY
// https://regexr.com/
// https://regexr.com/5nvc2

```

<br/>

## 특정 문자의 (검색 및) 제거

### 어떻게 문자열에 있는 특정 문자들을 제거할 수 있을까?

```swift
/**==========================================================
 [특정 문자들을 제거할때 사용하기 위한 메서드]
 1) 간단하게 앞뒤의 특정 문자를 제거하는 메서드
 - 문자열.trimmingCharacters(in: <#T##CharacterSet#>)
 
 2) 문자열의 중간에 특정 문자를 제거하는 방법 ⭐️
 "해당 특정 문자"를 기준으로 (잘라서) 문자열을 배열로 ===> (다시 배열을) 문자열로
 - 문자열.components(separatedBy: <#T##CharacterSet#>).joined()
 =========================================================**/
//CharacterSet.uppercaseLetters

// 1) 앞뒤의 공백문자의 제거
var userEmail = " my-email@example.com "
var trimmedString = userEmail.trimmingCharacters(in: [" "])
print(trimmedString)
// "my-email@example.com" (처음, 마지막의 공백 문자열 제거)

// CharacterSet 개념을 활용해서
trimmedString = userEmail.trimmingCharacters(in: .whitespaces)
print(trimmedString)


// 2) 앞뒤의 특정문자의 제거
var someString = "?Swift!"
var removedString = someString.trimmingCharacters(in: ["?","!"])
print(removedString) // Swift

someString = "?Swi!ft!"
removedString = someString.trimmingCharacters(in: ["?","!"])
print(removedString)       // 중간에 있는 !는 제거하지 못함

//:> 중간에 있는 특수문자의 제거 원리: 해당 특수문자를 기준으로 문자열을 배열로 만든다음 → 다시 문자열로 변환
// 3) (중간에 포함된)공백문자의 제거
var name = " S t e v e "
var removedName = name.components(separatedBy: " ").joined()    //["", "S", "t", "e", "v", "e", ""]
print(removedName)

// 4) (중간에 포함된)특수문자의 제거
var phoneNum = "010-1234-1234"
var newPhoneNum = phoneNum.components(separatedBy: "-").joined()   // ["010", "1234", "1234"]
print(newPhoneNum)

// 5) 여러개의 특수문자를 한꺼번에 제거
var numString =  "1+2-3*4/5"
var removedNumString =  numString.components(separatedBy: ["+","-","*","/"]).joined()
print(removedNumString)

// 6) components(separatedBy:)와 거의 동일한 메서드 split(separator:) 그러나 차이는 있음
var str =  "Hello Swift"
var arr = str.split(separator: " ")    // 서브스트링으로 리턴함
print(arr)
print(arr.joined())

// - (1) split은 Substring 배열로 리턴
str.split(separator: " ")

// - (2) split은 클로저를 파라미터로 받기도 함 (클로저에서 원하는 함수내용을 정의하면 되므로 활용도가 더 높을 수 있음)
str.split { $0 == " " }

//str.split(whereSeparator: <#T##(Character) throws -> Bool#>)
```

### (미리 정의된) 특정 문자 집합(Set)의 개념을 이용하면, 조금 더 편하게 사용 가능

```swift
// 구조체로 구현되어 있는
// 문자집합 (문자열 검색, 잘못된 문자 삭제 등에 주로 활용) (기본적인 Set성격)
/**=========================================
 [CharacterSet] 유니코드 기준
 - .symbols                // 기호
 - .alphanumerics          // 문자 + 숫자
 - .decimalDigits          // 10진법 숫자
 - .letters                // 문자 (유니코드상 Letter, Mark 카테고리 해당 문자)
 - .lowercaseLetters       // 소문자
 - .uppercaseLetters       // 대문자  ["A", "B", "C", "D", "E" ...]
 - .whitespaces            // 공백문자 [" "]
 - ....등등
 
 참고: https://developer.apple.com/documentation/foundation/characterset
 ============================================**/

// 문자셋을 활용해서
userEmail = " my-email@example.com "
var characterSet = CharacterSet.whitespaces   // 공백문자 집합
trimmedString = userEmail.trimmingCharacters(in: characterSet)
print(trimmedString) // "my-email@example.com"

name = " S t e v e "
removedName = name.components(separatedBy: characterSet).joined()
print(removedName) // "Steve"

var phoneNumbers = "010 1111 2222"
print(phoneNumbers.components(separatedBy: .whitespaces).joined()) // "01011112222"

// 특정 문자열 검색에도 활용 가능
name = "hello+world"

if let range = name.rangeOfCharacter(from: .symbols) {
    print(name[range]) // +
}
```

<br/>

<br/>

여기까지가 10월 4주차 기간동안 공부하고 복습한 내용입니다.

읽어주셔서 감사합니다.