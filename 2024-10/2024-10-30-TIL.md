# 2024-10-30-TIL

안녕하세요.

오늘은 프로세스의 주소 공간, 인터럽트에 대해 알아보도록 하겠습니다.

## 프로세스의 주소 공간

> 프로그램이 CPU에 의해 실행됨 => 프로세스가 생성되고 메모리에 **프로세스 주소 공간**이 할당 됨

프로세스 주소 공간에는 코드, 데이터, 스택으로 이루어져 있다.

- 코드 Segment: 프로그램 소스 코드 저장
- 데이터 Segment: 전역 변수 저장
- 스택 Segment: 함수, 지역 변수 저장

왜 이렇게 구역을 나눈걸까?

- 최대한 데이터를 공유하여 메모리 사용량을 줄여야 한다.
- Code는 같은 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유한다.
- Stack과 data를 나눈 이유는 스택 구조의 특성과 전역 변수의 활용성을 위한 것이다.

[![img](https://camo.githubusercontent.com/0bc0c938c1ced4e2ce7f7b90747a7129e63b7be3345797880186c71757a41d39/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323137343031333835384631424544373041)](https://camo.githubusercontent.com/0bc0c938c1ced4e2ce7f7b90747a7129e63b7be3345797880186c71757a41d39/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f323137343031333835384631424544373041)

- 프로그램의 함수와 지역 변수는 LIFO(Last In First Out) 특성을 가진 스택에서 실행된다.
- 따라서 이 함수들 안에서 공통으로 사용하는 '전역 함수'는 따로 지정해주면 메모리를 아낄 수 있다.

<br/>

## 인터럽트(Interrupt)

> 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것

- 지금 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야한다.
- 외부/내부 인터럽트는 **CPU의 하드웨어 신호에 의해 발생**
- 소프트웨어 인터럽트는 **명령어의 수행에 의해 발생**

### 외부 인터럽트

- 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생
- 전원 이상, 기계 착오, 외부 신호, 입출력

### 내부 인터럽트

- Trap 이라고 부르며, 잘못된 명령이나 데이터를 사용할 때 발생
- 0으로 나누기가 발생, 오버플로우, 명령어를 잘못 사용한 경우(Exception)

### 소프트웨어 인터럽트

- 프로그램 처리 중 명령의 요청에 의해 발생한 것 (SVC 인터럽트)
- 사용자가 프로그램을 실행시킬 때 발생
- 소프트웨어 이용 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.

### 인터럽트 발생 처리 과정

[![img](https://camo.githubusercontent.com/a652402783b9380c4738ec5b0d134b9c44e62f938f9eb322bb0f18fbf05357fb/68747470733a2f2f6d626c6f677468756d622d7068696e662e707374617469632e6e65742f32303136303331305f3132342f736377303533315f3134353735333636323931313035576a53375f504e472f4552545254455452452e706e673f747970653d7732)](https://camo.githubusercontent.com/a652402783b9380c4738ec5b0d134b9c44e62f938f9eb322bb0f18fbf05357fb/68747470733a2f2f6d626c6f677468756d622d7068696e662e707374617469632e6e65742f32303136303331305f3132342f736377303533315f3134353735333636323931313035576a53375f504e472f4552545254455452452e706e673f747970653d7732)

- 주 프로그램이 실행되다가 인터럽트가 발생했다.
- 현재 수행 중인 프로그램을 멈추고, 상태 레지스터와 PC 등을 스택에 잠시 저장한 뒤에 인터럽트 서비스 루틴으로 간다.
  - 잠시 저장하는 이유는 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문
- 만약 인터럽트 기능이 없었다면 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야 한다. (이를 폴링(Polling)이라고 한다.)
- 폴링을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하지 못하는 단점이 있었다.
- 컨트롤러가 입력을 받아들이는 방법(우선순위 판별방법)에는 두가지가 있다.
  - 폴링 방식
    - 사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식
    - 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다. (하드웨어에 비해 속도 느림)
  - 인터럽트 방식
    - MCU 자체가 하드웨어적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식
      - Daisy Chain
      - 병렬 우선순위 부여
- 인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다.
- 인터럽트는 **발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법**이다.

<br/>

오늘 공부한 내용은 여기까지 입니다.

읽어주셔서 감사합니다.