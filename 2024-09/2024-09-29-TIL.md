# 2024-09-29-TIL

## 9월 4주차 TIL 복습

안녕하세요.

오늘은 9월 4주차 기간 동안 쓴 TIL에 대해 복습하는 시간을 가져보겠습니다.

### WKWebView

#### JavScript <=> Native App(iOS) 데이터 전달

<img width="922" alt="Screenshot 2024-09-29 at 3 18 59 PM" src="https://github.com/user-attachments/assets/20fb1c7b-e006-4b7c-aa80-7341b0185123">

----

### 클래스의 상속

#### 기본 개념

클래스에서 상속은 다음과 같은 **개념**을 가지고 있습니다.

- 본질적으로 성격이 비슷한 타입을 새로 만들어 **1) 데이터(저장 프로퍼티)**를 추가하거나, **2) 기능(메서드)**를 변형시켜서 사용하려는 것입니다.
- 상속은 **유일하게 클래스에서만 지원하는 기능**입니다. **구조체는 상속이 불가능**합니다.
- 기본적으로 상속은 데이터(저장 프로퍼티)를 추가하는 관점에서 생각해야 합니다.
- Swift에서 **다중 상속은 불가능**합니다.

#### 재정의(Overriding)

> 부모 클래스로부터 상속 받은 프로퍼티와 메서드를 변형해서 다시 구현하는 것입니다.

재정의를 할때는 2가지 대원칙이 존재합니다.

첫 번째는 저장 프로퍼티는 재정의가 불가능하다는 것이고,

두 번째는 메서드는 재정의 가능하다는 것입니다.(다만, 기능 확장만 가능합니다.)

##### 저장 프로퍼티

- 저장 프로퍼티는 **메모리 구조에서 상위 구현을 참조하기 때문에 재정의(변형)가 불가능**합니다.
- 하지만, 메서드 형태로 부수적 추가는 가능합니다. 즉, 자식 클래스에서 부모 클래스의 저장 프로퍼티에 읽기/쓰기 계산 프로퍼티 형태나 프로퍼티 감시자 형태로 재정의가 가능합니다. 왜냐하면, 두 가지 프로퍼티 모두 단순히 메서드를 추가하는 형태이기 때문입니다.

##### 계산 프로퍼티

- 계산 프로퍼티는 확장 방식의 재정의가 가능합니다.
  - 읽기 => 읽기 / 쓰기 가능 (기능 확장 가능)
  - 읽기 / 쓰기 => 읽기는 불가능 (기능 축소 불가능)
- 프로퍼티 감시자를 추가하는 재정의는 가능합니다. 이는 실질적으로 단순 메서드 추가이기 때문입니다.

##### 생성자

- 생성자는 기본적으로 상속되지 않고 재정의하는 것이 원칙입니다. (생성자는 모든 저장 프로퍼티를 초기화하는 도구이기 때문에, 서브클래스에 최적화 되어 있지 않습니다.)
- 원칙적으로 **1) 상위 지정생성자**와 **2) 현재 단계의 저장 프로 프로퍼티**를 고려해서 구현해야 합니다.
- 예외: 생성자의 자동 상속 - 지정생성자 / 편의생성자 자동상속의 경우가 있습니다.

##### 메서드

- 일반적으로 상위구현의 메서드를 대체 및 변형 할 수도 있으므로, 자유롭게 재정의가 가능합니다. (상위 구현을 호출하는 경우도 많으니 주의해야 합니다.)

---

### 생성자의 종류

#### 지정 생성자(Designated Initializer)

> init( ... ) 형태를 가지는 생성자

지정 생성자는 다음과 같은 **특징**을 가지고 있습니다.

- 지정 생성자는 모든 저장 프로퍼티를 초기화해야 함
  - 저장 프로퍼티의 선언과 동시에 값을 저장하거나, 저장 프로퍼티를 옵셔널 타입으로 선언하는 것도 가능
- 오버로딩이 가능하므로, 다양한 파라미터 조합으로 지정 생성자 구현 가능
- (따로 지정하지 않아도) 모든 저장 프로퍼티가 초기화 되는 경우, 기본 생성자 자동 제공 —> **init()**
- 만약, **생성자를 1개 이상 구현하면 기본 생성자를 제공하지 않음**

#### 편의 생성자(Convenience Initializer)

> 지정 생성자보다 적은 갯수의 파라미터로 보다 편리하게 생성하기 위한 서브 개념의 생성자

편의 생성자는 다음과 같은 **특징**을 가지고 있습니다.

- 편의 생성자(convenience)는 지정 생성자(designated)에 의존 및 호출(지정 생성자가 저장 프로퍼티 초기화)
- **초기화 과정을 간편하게 제공하기 위함**
- 실질적으로 가능한 지정 생성자의 갯수를 줄이고, 편의 생성자에서 지정 생성자 호출하도록 하는 것이 바람직
- 상속했을 때, 편의 생성자의 경우 **서브 클래스에서 재정의를 못함**(하위에서 호출불가가 원칙)
- 편의 생성자는 다른 편의 생성자를 호출하거나, 지정 생성자를 호출해야함(궁극적으로는 지정 생성자를 호출)

#### 필수 생성자(Required Initializer)

> 클래스의 생성자 앞에 **required**(필수의) 키워드를 붙이면 하위 클래스에서 반드시 **해당 생성자**를 구현해줘야 하는 생성자
>
> 해당 생성자의 의미는 **파라미터 이름 및 타입이 동일하다는 것을 말합니다.**

필수 생성자는 다음과 같은 **특징**을 가지고 있습니다.

- 하위 클래스에서 필수 생성자 구현 시, **override(재정의) 키워드 없이 required(필수의) 키워드만 붙이면 됩니다.**
- **필수 생성자의 자동 상속 조건**은 다음과 같습니다.
  - 다른 지정 생성자를 구현 안 하면, 자동으로 필수 생성자가 상속 됩니다.
  - 다른 지정 생성자를 구현하면, 필수 생성자를 다시 구현해야 합니다.

#### 실패가능 생성자(Failable Initializer)

> 인스턴스 생성시, 실패 가능성을 가진 생성자
>
> 실패가 불가능하게 만들어서, 아예 에러가 나고 앱이 완전히 꺼지는 가능성보다는 실패 가능성 생성자를 정의하고 그에 맞는 예외 처리를 하는 것이 더 올바른 방법입니다.

실패가능 생성자는 다음과 같은 **특징**을 가지고 있습니다.

- 인스턴스 생성 실패시 **nil을 리턴**
- 생성자에 ?을 붙여서, init?(…)으로 정의(다만, 오버로딩으로 인한 구분이 안되므로, 해당 이름을 가진 생성자는 유일한 생성자여야 함)
- **init?(실패 가능 생성자)은 init(실패 불가능 생성자)보다 더 넓은 개념**
- 동일 단계 / 상속 관계에서의 호출할 때
  - **실패 불가능 생성자**는 다른 **실패가능 생성자**를 호출 불가능
- 상속 관계에서의 **재정의**할 때
  - (상위) **init?** —> (하위) **init** (O) (강제 언래핑 활용 가능)
  - (상위) **init** —> (하위) **init?** (X)

#### 소멸자(Deinitializer)

> 인스턴스 해제 시, 정리가 필요한 내용을 정의하는 생성자

소멸자는 다음과 같은 **특징**을 가지고 있습니다.

- 클래스에는 최대 1개의 소멸자(Deinitializer)가 존재
- 인스턴스가 메모리에서 제거되기 직전에 자동으로 호출되는 메서드 부분

---

### 타입 캐스팅

#### is 연산자

> 인스턴스 타입에 대한 검사를 수행하는 연산자

is 연산자의 사용형태는 **인스턴스 이름 is 클래스 타입** 입니다. 결과 타입은 Bool 타입입니다.

#### as 연산자

> 인스턴스 타입의 (메모리 구조에 대한) 힌트를 변경하는 연산자

as 연산자에는 업캐스팅(Upcasting)과 다운캐스팅(Downcasting)의 개념이 있습니다.

##### 업캐스팅(Upcasting)

- **인스턴스 as 타입**과 같은 형태로 사용합니다.
- 하위 클래스의 메모리 구조로 저장된 인스턴스를 상위 클래스 타입으로 인식합니다.

##### 다운캐스팅(Downcasting)

- as? 연산자

  - **인스턴스 as? 타입**과 같은 형태로 사용합니다.

  - 참이면 반환 타입은 Optional 타입입니다. (실패 가능성을 가지고 있기 때문 입니다.)
  - 실패시 nil을 반환합니다.

- as! 연산자

  - **인스턴스 as! 타입**과 같은 형태로 사용합니다.
  - 참이면 반환 타입은 Optional 타입의 값을 강제 언래핑한 타입입니다.
  - 실패 시 런타임 오류를 발생시킵니다.

타입 캐스팅의 **의미**는 다음과 같습니다.

- 인스턴스 사용 시에 어떤 타입으로 사용할 지(프로퍼티/메서드) **메모리 구조에 대한 힌트를 변경하는 것**입니다.
- 메모리의 값을 수정하는 것은 아닙니다. (단순히 해당 타입의 인스턴스인 것처럼 취급하려는 목적입니다.)

### 다형성(Polymorphism)

- 하나의 객체(인스턴스)가 여러가지 타입으로 표현될 수 있습니다. 
- 또는 하나의 타입으로 여러 종류의 객체(인스턴스)를 여러가지 형태(모습)으로 해석될 수 있는 성격을 의미합니다.
- 다형성은 클래스의 상속(+ 프로토콜)과 깊은 연관성이 있습니다.

### Any와 AnyObject

> 불특정한 타입을 다룰 수 있는 타입 (범용적인 타입)

- Any 타입
  - 기본 타입(Int, String, Bool, …) 등 포함, 커스텀 클래스, 구조체, 열거형, 함수타입까지도 포함해서 어떤 타입의 인스턴스도 표현할 수 있는 타입(옵셔널 타입도 포함)

- AnyObject 타입
  - 어떤 클래스 타입의 인스턴스도 표현할 수 있는 타입입니다.

---

### 확장(Extension)

### 상속과 확장의 비교

|               | 상속                                                         | 확장                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 개념적인 방향 | **수직적 개념**<br />**성격이 비슷한 "타입을 새로" 만들어, 데이터를 추가하고, 기능(메서드)을 변형시켜 사용하려는 것**입니다. | **수평적 개념**<br />**현재 존재하는 타입에 기능(메서드)을 추가**하여 사용하려는 것입니다.<br />현재 존재하는 타입에 확장(새로운 기능 추가)하는 것입니다.<br />새 기능을 추가할 수 있지만 기존 기능을 재정의 할 수는 없습니다. |
| 가능한 타입   | 클래스                                                       | 클래스, 구조체, 열거형                                       |

### 확장 가능한 맴버의 종류

1. (타입) 계산 프로퍼티, (인스턴스) 계산 프로퍼티
2. (타입) 메서드, (인스턴스) 메서드
3. 새로운 생성자(다만, **클래스의 경우 편의 생성자만 추가 가능**하고, **값 타입(구조체, 열거형)의 경우, 지정 생성자 형태로도 (자유롭게) 생성자 구현이 가능**합니다.)
4. 서브 스크립트
5. 새로운 중첩 타입 정의 및 사용
6. 프로토콜 채택 및 프로토콜 관련 메서드

----

### 프로토콜(Protocols)

#### 프로토콜의 필요성에 대한 인식 - 클래스와 상속의 단점

- 클래스 상속의 단점 
  1. **하나의 클래스만 상속**가능 (다중 상속 불가능)
  2. 기본적인 상위 클래스의 **메모리 구조**를 따라갈 수 밖에 없음 (필요하지 않은 프로퍼티/메서드도 상속됨)
  3. **클래스(레퍼런스 타입)**에서만 가능

### 프로토콜의 기본문법

#### 1. 정의

프로토콜(즉, 규약)을 만들어 필요한 요구사항만을 담습니다.

```swift
protocol MyProtocol {
    // "요구사항만"을 정의
    func doing() -> Int
}
```

#### 2. 채택

프로토콜을 채택합니다. (클래스 뿐만 아니라, 구조체, 열거형에서 채택 가능합니다.)

```swift
class MyClass: MyProtocol {
   ...
}

// 상속이 있는 경우의 문법
// 상속하려는 클래스 먼저 선언
// 그 다음 채택하려는 프로토콜 선언
class Person: Student, MyProtocl { 
   ... 
}
```

#### 3. 구현

프로토콜에서 **요구하는 사항(프로퍼티 / 메서드)**을 직접 구현합니다.

확장을 통해서 프로토콜의 구체적인 구현 내용을 정의 가능합니다.

```swift
class MyClass: MyProtocol {
    func doing() -> Int {
        print("return doing")
        return 0
    }
}
```

### 프로토콜의 요구사항의 종류 

프로토콜을 채택하려는 클래스, 구조체, 열거형에 최소한 이런 내용을 구현해야 한다고 선언하는 부분입니다.

1. 프로퍼티 요구사항
2. 메서드 요구사항 (메서드 / 생성자 / 서브스크립트)

#### 1. 프로퍼티의 요구사항을 정의

- 인스턴스 프로퍼티 요구사항
  - 최소한의 요구사항을 지정
  - 저장 프로퍼티 / 계산 프로퍼티로 모두 구현 가능 (프로토콜 요구사항만으로는 저장 / 계산  프로퍼티의 구별 불가)

|               | { get }                        | { get set }        |
| ------------- | ------------------------------ | ------------------ |
| 저장 프로퍼티 | let / var                      | var                |
| 계산 프로퍼티 | 읽기(get) / 읽기 쓰기(get/set) | 읽기 쓰기(get/set) |

- 타입(static) 프로퍼티 요구사항
  - **최소한의 요구사항**을 지정
  - 저장 타입 프로퍼티 / 계산 타입 프로퍼티로 모두 구현 가능 (프로토콜의 요구사항만으로는 저장 / 계산 프로퍼티의 구별 불가)
  - 채택 시 **저장 타입 프로퍼티에서 static으로만 구현 가능**(저장 프로퍼티 재정의 불가 원칙)
  - 클래스에서 채택 시 **계산 타입 프로퍼티에서 static / class 키워드로 모두 구현 가능**(타입 프로퍼티의 의미일 뿐입니다.)

**예제 코드**는 아래와 같습니다.

```swift
protocol RemoteMouse {
    var id: String { get } // ---> let 저장프로퍼티 / var 저장프로퍼티 / 읽기 계산프로퍼티 / 읽기, 쓰기 계산프로퍼티
    var name: String { get set } // ---> var 저장프로퍼티 / 읽기, 쓰기 계산 프로퍼티
    static var type: String { get set } // ---> 타입 저장 프로퍼티 (static)
    // ---> 타입 계산 프로퍼티 (class)
}

// 채택하면, (최소한의) 요구사항을 정확하게 따라서 구현해야 함.
// 인스턴스 저장 / 계산 프로퍼티 =========================
struct TV: RemoteMouse {
    var id: String = "456"
    var name: String = "삼성티비"
    static var type: String = "리모컨"
}

let myTV = TV()
myTV.id // "456"
myTV.name // "삼성티비"
TV.type // "리모컨"

// 타입 프로퍼티 =============================
// 1) 저장 타입 프로퍼티로 구현
class SmartPhone: RemoteMouse {
    var id: String {
        return "777"
    }
    
    var name: String {
        get { "아이폰" }
        set { }
    }
    
    static var type: String = "리모컨" // 타입 저장 프로퍼티는 (상속은 되지만) 재정의 원칙적 불가능
}

// 2) 계산 타입 프로퍼티로 구현
class Ipad: RemoteMouse {
    var id: String = "777"
    var name: String = "아이패드"
    
    class var type: String { // 타입 계산 프로퍼티는 재정의 가능 (class 키워드 가능)
        get { "리모컨" }
        set { }
    }
}
```

#### 2. 메서드의 요구사항을 정의

##### 2-1. 메서드 요구사항

- 메서드의 헤드부분(인풋/아웃풋)을 정의
- mutating 키워드
  - 구조체로 제한하는 것은 아닙니다.
  - 구조체에서 저장 프로퍼티를 변경하는 경우, 구조체도 채택 가능하도록 허락하는 키워드입니다.
- 타입 메서드
  - 클래스에서 채택 시 **static / class 키워드로 모두 구현 가능**합니다. (class 키워드는 재정의 가능합니다.)

```swift
// 1) 정의
protocol RandomNumber {
    static func reset()  // 최소한 타입 메서드가 되야 함 (class로 구현해서 재정의를 허용하는 것도 가능)
    func random() -> Int
    // mutating func doSomething()
}

// 2) 채택 / 3) 구현
class Number: RandomNumber {
    static func reset() {
        print("다시 셋팅")
    }
    func random() -> Int {
        return Int.random(in: 1...100)
    }
}

let n = Number()
n.random() // 1~100까지 범위 내에서 랜덤한 Int 값 반환
Number.reset() // 다시 셋팅

// 1) 정의
protocol Togglable {
    mutating func toggle() // mutating의 키워드는 메서드 내에서 프로퍼티 변경의 의미일 뿐 (클래스에서 해당 메서드 사용 가능)
}

// 2) 채택 / 3) 구현
enum OnOffSwitch: Togglable {
    case on
    case off
    
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}

var s = OnOffSwitch.off
s.toggle() // on
s.toggle() // off

class BigSwitch: Togglable {
    var isOn = false
    
    func toggle() { // mutating 키워드 필요없음 (클래스이기 때문에)
        isOn = isOn ? false : true
    }
}

var big = BigSwitch()
print(big.isOn) // false
big.toggle()
print(big.isOn) // true
```

##### 2-2. 생성자 요구사항

- 생성자를 요구사항으로 지정 가능합니다.
- (1) 클래스에서 생성자 채택 시, (하위 클래스를 고려) required(필수적)를 붙여야 합니다.
- (2) 클래스가 final로 선언되면 required 생략 가능합니다.
- (3) 클래스에서는 반드시 지정생성자로 구현할 필요는 없습니다.(편의 생성자로 구현도 가능합니다.)

> init?() 실패가능 생성자 선언 => init() / init?() / init!()로 구현 가능합니다.
>
> init() 실패불가능 생성자 선언 => init?()로 구현할 수 없습니다. (더 넓은 범위로 구현 X)

```swift
// 예제 1
class SomeClass: SomeProtocol {
    required init(num: Int) {
        // 실제 구현
    }
}

class SomeSubClass: SomeClass {
    // 하위 클래스에서 생성자 구현 안하면 필수 생성자는 자동 상속
    // required init(num: Int)
}

// 예제 2
protocol AProtocol {
    init()
}

class ASuperClass: SomeClass {
    // 하위 클래스에서 생성자 구현 안하면 필수 생성자는 자동 상속
    // required init(num: Int)
}

class ASuperClass {
    init() {
        // 생성자의 내용 구현
    }
}

class ASubClass: ASuperClass, AProtocol {
    // AProtocol을 채택함으로 "required" 키워드 필요하고, 상속으로 인한 "override(재정의)" 재정의 키워드도 필요
    required override init() {
        // 생성자의 내용 구현
    }
}
```

##### 2-3. 서브스크립트 요구사항

- 최소한의 요구사항을 지정합니다.

> { get } => 읽기(get) / 읽기쓰기(get/set)
>
> { get set } => 읽기쓰기(get/set)

```swift
protocol DataList {
    subscript(idx: Int) -> Int { get } // (서브스크립트 문법에서) get 필수 (set 선택)
}

struct DataStructure: DataList {
    subscript(idx: Int) -> Int { // (최소한만 따르면 된다.)
        get {
            return 0
        }
        set { // 구현은 선택
            
        }
    }
}
```

<br/>

<br/>

여기까지가 9월 4주차 TIL에 대한 내용들입니다.

내용이 정말 많네요..!

읽어주셔서 감사합니다.

