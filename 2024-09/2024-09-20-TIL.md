# 2024-09-20-TIL

## 속성(Property)과 메서드(Method)

안녕하세요.

저번 시간에는 클래스와 구조체에 대해서 간략하게 알아봤습니다.

오늘은 클래스와 구조체에서 프로퍼티에 대해서 조금 더 자세하게 알아보도록 하겠습니다.

### 구조체(struct)와 클래스(class)의 프로퍼티와 메서드 종류의 큰 그림

먼저, 구조체와 클래스에서 사용되는 프로퍼티와 메서드 종류에 대해서 큰 그림을 그려보도록 하겠습니다.

|                  | 구조체(struct)                                               | 클래스(class)                                                |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 속성(Properties) | 저장(Stored) 프로퍼티<br />지연(Lazy) 저장 프로퍼티<br />계산(Computed) 프로퍼티- 읽기(get)/쓰기(set)  <br />타입(Type) 프로퍼티 - 저장/계산 <br />프로퍼티 감시자(Property Observers) —> willSet / didSet | 저장(Stored) 프로퍼티<br />지연(Lazy) 저장 프로퍼티<br />계산(Computed) 프로퍼티- 읽기(get)/쓰기(set)  <br />타입(Type) 프로퍼티 - 저장/계산 <br />프로퍼티 감시자(Property Observers) —> willSet / didSet |
| 메서드(Methods)  | 인스턴스 메서드 (mutating 키워드 - 속성 변경 가능)  <br />타입 메서드  <br />서브 스크립트  <br />생성자 <br />—> Memberwise 생성자(저장 프로퍼티에 관한 자동 생성자) <br />—> 지정 생성자(Designated) <br />—> 실패 가능 생성자(Failable) | 인스턴스 메서드  <br />타입 메서드  <br />서브 스크립트  생성자 <br />—> 지정 생성자(Designated) <br />—> 편의 생성자(Convenience) <br />—> 필수 생성자(Required) <br />—> 실패 가능 생성자(Failable)<br />  소멸자 |

<br/>

그럼 지금부터 세부적으로 각 프로퍼티에 대해서 알아보도록 하겠습니다.

### 속성(Property)

#### 저장 프로퍼티(Stored Property)

> 클래스와 구조체 틀에서 생성한 **각 인스턴스가 가지는 고유의 데이터 저장 공간**

저장 프로퍼티는 아래와 같은 **특징**을 가지고 있습니다.

- 변수(var)나 상수(let)로 선언 가능합니다.
- 인스턴스의 초기화 시, 각 저장 프로퍼티는 반드시 값을 가져야 합니다.
  - 기본 값을 설정하거나 생성자에서 설정 또는 옵셔널 타입으로 선언하여 기본값 nil을 초기값으로 갖는 것도 가능합니다.
- 열거형의 경우 따로 메모리 공간이 필요한 저장 프로퍼티는 선언할 수 없습니다.

저장 프로퍼티의 **코드 예시**는 다음과 같습니다.

```swift
struct Person {
    var name: String = "myungsun" // 저장 프로퍼티 --> 기본 값이 없으면, 생성자를 통해 값을 반드시 초기화 해야 함. 
    var weight: Double = 80.2  // 저장 프로퍼티
		
    ...
}

var myungsun = Person(name: "mui", weight: 75.3)
```

#### 지연 저장 프로퍼티(Lazy Stored Properties)

> 값에 대한 접근이 있을 때 초기화(메모리 공간 생성)되는 프로퍼티

지연 저장 프로퍼티는 아래와 같은 **특징**을 가지고 있습니다.

- 해당 프로퍼티가 반드시 처음부터 초기화가 필요하지 않은 경우(일반적으로 많은 메모리 공간을 차지하는 이미지 등)에 초기화를 지연시킵니다. 이로 인해, 불필요한 성능 저하나, 메모리 공간의 낭비를 줄일 수 있습니다.
- lazy var로만 선언이 가능하고 lazy let으로는 선언이 불가능합니다.
- 생성자에서 초기화를 시키지 않기 때문에 선언 시점에 **기본 값**을 저장해야 합니다.
  - 기본 값은 표현식의 어떤 형태든 상관 없이 return 타입만 일치하면 됩니다. (함수 실행문, 계산식, 클로저, 실행문 등)

이런 특징을 가지는 지연 저장 프로퍼티를 **사용하는 이유**는 다음과 같습니다.

- 메모리 공간의 낭비를 막을 수 있습니다.

- 지연 저장 프로퍼티로 선언되는 프로퍼티가 다른 저장 프로퍼티를 이용해야 하는 경우가 있기 때문입니다.

  ```swift
  class AView: UIView {
      var number: Int = 0
      lazy var result: Int {
          // result 지연 저장 프로퍼티가 number 저장 프로퍼티를 이용해야 하는 경우
          // 초기화 시점이 result가 더 늦으므로, 먼저 초기화되는 number 저장 프로퍼티를 사용 가능
          return number * 20
      }()
  }
  ```

지연 저장 프로퍼티의 코드 예시는 다음과 같습니다.

```swift
struct Person {
    var name: String = "myungsun" // 저장 프로퍼티 --> 기본 값이 없으면, 생성자를 통해 값을 반드시 초기화 해야 함. 
    lazy var weight: Double = 80.2  // 저장 프로퍼티
		
    ...
}

var myungsun = Person(name: "mui", weight: 75.3)
myungsun.weight // 해당 프로퍼티에 접근하는 이 시점에 초기화가 됩니다.(메모리 공간이 생기고, 값이 저장됩니다)
```

<br/>

<br/>

다음으로 계산 프로퍼티를 알아보기 전에 메서드(method)가 메모리에서 어떻게 동작하는 지 코드 예시와 함께 알아보도록 하겠습니다.

```swift
class Person {
    var name: String 
    var age: Int
  
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
  
    func study() {
        print("공부를 합니다.")
    }
  
    func eat() {
        print("밥을 먹습니다.")
    }
}

var myungsun = Person(name: "myungsun", age: 20)
myungsun.study()  // 공부를 합니다. 
myungsun.eat()  // 밥을 먹습니다.
```

위와 같은 예시 코드에서 **Person이라는 클래스를 정의하고 인스턴스를 생성하면 메모리에서는 어떤 일들이 발생할까요?** (저번 시간에 알아본 클래스와 구조체를 알아볼 때 공부한 내용입니다.)

- Person이라는 **클래스 틀**은 메모리 **데이터 영역**에 저장이 됩니다.
- myungsun이라는 **인스턴스의 프로퍼티**는 메모리 **힙 영역**에 저장이 됩니다.
- myungsun이라는 **인스턴스의 프로퍼티 데이터들을 가리키는 메모리 주소**는 메모리 **스택 영역**에 저장이 됩니다.

다음으로 **myungsun.study() 메서드를 호출하면 메모리에서는 어떤 일들이 발생할까요?**

1. 메모리 **스택 영역**에 저장되어 있는 myungsun 메모리 주소를 찾아갑니다.
2. myungsun 메모리 주소가 가리키는 메모리 **힙 영역**에 있는 myungsun 인스턴스의 프로퍼티 데이터가 메모리 데이터 영역에 있는 Person 클래스 틀 안에 있는 study() 메서드 메모리 주소를 가리킵니다.
3. 메모리 **데이터 영역**에 있는 study() 메서드 메모리 주소를 통해 메모리 코드 영역으로 이동해 study() 메서드의 명령어 묶음을 실행시킵니다.
4. study() 메서드를 싱행시키게 되면 메모리 **스택 영역**에 study() 메서드의 프레임이 생성됩니다.
5. study() 메서드 실행이 끝나면 메모리 **스택 프레임**에서 사라지게 됩니다.

참고로, 구조체(struct)의 경우에는 인스턴스 생성 시 메모리 스택 영역에 해당 인스턴스의 프로퍼티 값들이 저장되는데, 인스턴스에서 메서드를 호출하게 되면 메모리 코드 영역의 메서드 메모리 주소에 바로 접근하게 됩니다.

<br/>

#### 계산 프로퍼티(Computed Property)

> **프로퍼티의 형태를 가진 실질적 메서드**입니다. 즉, 일반적으로 다른 저장 프로퍼티에 의존한 결과로 나오는 그런 방식의 메서드를 프로퍼티처럼 만든 것 입니다.

계산 프로퍼티는 다음과 같은 **특징**을 가지고 있습니다.

- 메서드이기 때문에 인스턴스에 **메모리 공간이 할당되어 있지 않습니다.**
- **var로만 선언 가능하고, 자료형까지 선언해야 합니다.**(형식 추론 방식 안됨) (메서드이기 때문에 파라미터, 리턴형이 필요한 개념)
- **get 블록**만 선언하면 **읽기 전용(read-only) 계산 프로퍼티가 됩니다.** **(필수 구현)**
- **set 블록**은 **선택적으로 구현**할 수 있습니다. (set만 구현하는 것은 불가능합니다.)
- **set 블록**에서 **기본 파라미터** **newValue**가 제공됩니다. (newValue가 아닌 직접 파라미터 이름 설정도 가능합니다.)

메서드가 아닌, 계산 프로퍼티 방식으로 구현했을 때 **장점**은 다음과 같습니다.

- 관련 있는 2가지 메서드(함수)를 한번에 구현할 수 있습니다.
- 외부에서 보기에 프로퍼티 이름으로 설정 가능하므로 보다 명확해 보입니다. 따라서, 계산 프로퍼티는 메서드를 개발자들이 보다 읽기 쉽고, 명확하게 쓸 수 있는 형태인 프로퍼티로 변환해 놓은 것입니다.

계산 프로퍼티의 **코드 예시**는 다음과 같습니다.

```swift
class Rectangle {
    var width: Double
    var height: Double
    
    init(width: Double, height: Double) {
        self.width = width
        self.height = height
    }
  
    // 읽기 전용 계산 프로퍼티
    var area: Double {
        // 읽기만 가능한 계산 프로퍼티는 get 블록은 생략 가능
        return width * height
    }
    
    // 읽기 쓰기가 가능한 계산 프로퍼티
    var perimeter: Double {
        get { // getter => 값을 얻는다는 의미
            return 2 * (width + height)
        }
        set { // setter => 값을 세팅한다(넣는다)는 의미
            // newValue는 새로 설정하려는 값을 나타냅니다
            let side = newValue / 4
            width = side
            height = side
        }
    }
}

// 사용 예시
var rectangle = Rectangle(width: 5, height: 3)
print("면적: \(rectangle.area)") // 출력: 면적: 15.0
print("둘레: \(rectangle.perimeter)") // 출력: 둘레: 16.0

rectangle.perimeter = 40
print("새로운 너비: \(rectangle.width)") // 출력: 새로운 너비: 10.0
print("새로운 높이: \(rectangle.height)") // 출력: 새로운 높이: 10.0
```

위 코드 예시에서 **rectangle.perimeter를 실행하면 메모리에서는 어떤 일들이 발생할까요?**

1. 메모리 힙 영역에 있는 rectangle 프로퍼티 데이터들이 메모리 데이터 영역에 있는 Rectangle 클래스 틀 안에 있는 **rectangle.get()** 메서드 메모리 주소를 가리킨다.
2. 메모리 데이터 영역에 있는 **rectangle.get()**  메서드의 메모리 주소를 통해 메모리 코드 영역으로 이동해 **rectangle.get()** 메서드의 명령어 묶음을 실행시킨다.
3. **rectangle.get()** 메서드를 실행시키게 되면 메모리 스택 영역에 **rectangle.get()** 메서드의  프레임이 생성된다.
4. **rectangle.get()**  메서드 프레임 안에는 rectangle 인스턴스의 메모리 주소가 들어있고, 이 메모리 주소를 통해 실제 인스턴스 프로퍼티의 데이터를 저장하고 있는 메모리 **힙 영역**에서 필요한 데이터에 접근해서 get 연산을 수행한다.

다음으로, **rectangle.perimeter = 40을 실행하면 메모리에서는 어떤 일들이 발생할까요?**

1. 메모리 힙 영역에 있는 rectangle 프로퍼티 데이터들이 메모리 데이터 영역에 있는 Rectangle 클래스 틀 안에 있는 **rectangle.set()** 메서드 메모리 주소를 가리킨다.
2. 메모리 데이터 영역에 있는 **rectangle.set()**  메서드의 메모리 주소를 통해 메모리 코드 영역으로 이동해 **rectangle.set()** 메서드의 명령어 묶음을 실행시킨다.
3. **rectangle.set()** 메서드를 실행시키게 되면 메모리 스택 영역에 **rectangle.set()** 메서드의  프레임이 생성된다.
4. **rectangle.set()**  메서드 프레임 안에는 rectangle 인스턴스의 메모리 주소가 들어있고, 이 메모리 주소를 통해 실제 인스턴스 프로퍼티의 데이터를 저장하고 있는 메모리 **힙 영역**에서 필요한 데이터에 접근해서 set 연산을 수행한다.

<br/>

#### 타입 프로퍼티(Type Property)

> **인스턴스에 포함되는 프로퍼티가 아니고, 타입 자체에 포함되는 프로퍼티**
>
> **메모리 데이터 영역에 저장**

타입 프로퍼티는 다음과 같은 **특징**을 가지고 있습니다.

- 인스턴스에 포함된 프로퍼티가 아니고, 타입 자체에 포함되는 프로퍼티이기에 **내/외부에서 Type.property로 접근해야 합니다.**
- 저장 타입 프로퍼티를 주로 사용합니다.

타입 프로퍼티의 **종류**는 아래와 같습니다.

1. `저장 타입 프로퍼티`
   - **모든 인스턴스가 동일하게 가져야하는 보편적인 프로퍼티**이거나, **모든 인스턴스가 공유해야하는 성격에 가까운 저장 프로퍼티**를 저장 타입 속성으로 선언합니다.
   - **static** 키워드를 사용합니다. **(상속 시)재정의 불가**(메서드만 상속이 가능 - **class** 키워드 사용 불가)
   - let / var 선언 둘다 가능합니다.(저장 타입 프로퍼티)
   - 항상 기본값(초기값)이 필요합니다.(생성자에 의한 값 설정 과정이 없기 떄문입니다.)
   - **메모리 구조**
     - **일반 저장 프로퍼티**는 인스턴스를 생성할 때, 생성자에서 모든 속성을 초기화를 완료합니다. 그리고, 해당 저장 속성은 각 인스턴스가 가진 **고유한 값**입니다.
     - 하지만, **저장 타입(형식) 프로퍼티**는 생성자가 따로 없기 때문에, 타입 자체(유형 그 자체)에 속한 속성이기 때문에 항상 기본 값이 필요합니다. (= 생략할 수 없음)
     - **저장 타입 프로퍼티**는 **지연 속성의 성격을 가지고 있습니다.**
       - 저장 타입 프로퍼티는 기본적으로 지연 속성(속성에 처음 접근하는 순간에 초기화 됨)이지만, lazy라고 선언할 필요는 없습니다. 
         - **(참고: 여러 스레드에서 동시에 엑세스하는 경우에도 한 번만 초기화되도록 보장됩니다. Thread-Safe)**
2. `계산 타입 프로퍼티`
   - **(상속 시)재정의 가능**합니다. (class 키워드 사용 시에만)
   - static 또는 class 키워드를 사용합니다. (static 상속 시 재정의 불가 / class 상속 시 재정의 가능 의미를 가지고 있습니다.)
   - var 키워드만 사용 가능합니다. (계산 타입 프로퍼티)
   - 메서드이기 때문에 타입에 **메모리 공간이 할당되어 있지 않습니다.**(계산 프로퍼티의 특징)

타입 프로퍼티의 **코드 예시**는 다음과 같습니다.

```swift
// static(고정적인/고정된)이라는 키워드를 추가한 저장 프로퍼티
class Circle {
    // (저장) 타입 프로퍼티 (값이 항상 있어야 함) 
	  static let pi: Double = 3.14 
	  static var count: Int = 0 // 인스턴스의 갯수를 나타내는 프로퍼티

	  // (계산) 타입 프로퍼티(read-only) 
	  static var multiPi: Double {
		  return pi * 2 
	  } 
		
	  // 저장 프로퍼티
	  var radius: Double // 반지름 

	  // 계산 프로퍼티
	  var diameter: Double { 
		  get { 
			  return radius * 2 
		  }
		  set {
			  radius = newValue / 2 
		  }
	  }

	  // 생성자 
	  init(radius: Double) {
		  self.radius = radius 
		  Circle.count += 1 
	  }
}

var aCircle = Circle(radius: 10)
aCircle.radius
aCircle.diameter
Circle.count // 인스턴스를 +1개 찍어냄

var bCircle = Circle(radius: 20)
bCircle.count // 인스턴스를 +1개 찍어냄 
```

<br/>

#### 프로퍼티 감시자(Property Observer)

> **저장 프로퍼티의 변화 시점을 관찰하는 실질적 메서드**

프로퍼티 감시자는 다음과 같은 **특징**을 가지고 있습니다.

- **저장 프로퍼티 자체는 var로만 선언 가능합니다.**(let은 관찰필요 없음, 지연저장 속성은 관찰 안됨)
- **자료형을 선언하는 것은 일반 변수와 동일합니다.**(기본값을 넣으면 형식 추론 방식 가능함)
- 저장 프로퍼티의 변화시점을 관찰하는 실질적 메서드입니다. (타입/인스턴스 둘다 가능은 함)
  - 상속한 계산 프로퍼티를 재정의해 관찰 가능하지만 주로 저장 프로퍼티에서 사용합니다.
- **willSet** 또는 **didSet** 중에서 한가지만 구현하면 됨(일반적으로 didSet으로 구현)
  - **willSet** —> (값이 변할때) 새 값이 **저장되기 직전에 호출됩니다.**
  - **didSet** —> (값이 변할때) 새 값이 **저장된 직후에 호출됩니다.**
- 변수가 변하면, (무엇인가) 업데이트 하려는 패턴 구현할 때 사용합니다.
  - 예시) 상태 메시지, 프로필 사진 서버에서 변화 —> (바로) 화면 업데이트

**프로퍼티 감시자를 추가 가능한 경우**는 다음과 같습니다.

1. **저장 프로퍼티**(**상속한 저장 프로퍼티는 재정의가 불가능**하지만, **감시자는 추가 가능**합니다.)
2. **상속한 계산 프로퍼티를 재정의**해 속성관찰자를 추가할 수 있습니다. (단순 메서드 추가일뿐입니다.)
   - 본래의 계산 프로퍼티에는 setter에서 값의 변경을 관찰 가능하므로 추가가 불가능합니다.

프로퍼티 감시자의 코드 예시는 다음과 같습니다.

```swift
class Profile {
    // 일반 저장 프로퍼티
    var name: String = "이름"
		
	  // 저장 프로퍼티 + 저장 프로퍼티가 변하는 시점을 관찰하는 메서드 
	  var statusMessage: String = "기본 상태 메시지" {
		  willSet { // willSet(파라미터 이름) 형태로도 사용 가능 
			  print("메시지가 \(statusMessage)에서 \(newValue)로 변경될 예정입니다.")
			  print("상태 메시지 업데이트 준비")
		  }
		  didSet { // didSet(파라미터 이름) 형태로도 사용 가능 
			  print("메시지가 \(oldValue)에서 \(statusMessage)로 이미 변경되었습니다.")
			  print("상태 메시지 업데이트 완료")
		  }
	  }
}

let aProfile = Profile()
aProfile.name // 이름 
aProfile.name = "myungsun" 

aProfile.statusMessage // 기본 상태 메시지  
aProfile.statusMessage = "iOS"
// 호출 순서
// willSet -->  statusMessage[   "iOS"   ] --> didSet 

// 결과
// 메시지가 기본 상태 메시지에서 iOS로 변경될 예정입니다.
// 상태 메시지 업데이트 준비 
// 메시지가 기본 상태 메시지에서 iOS로 이미 변경되었습니다. 
// 상태 메시지 업데이트 완료 
```

<br/>

양이 꽤 많네요..!

오늘은 클래스, 구조체에서 프로퍼티 종류에 대해서 자세하게 알아보는 시간이었습니다.

다음에는 클래스, 구조체 메서드 종류에 대해서 자세하게 알아보도록 하겠습니다.

감사합니다.